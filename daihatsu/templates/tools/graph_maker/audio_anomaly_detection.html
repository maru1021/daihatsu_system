<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ•ãƒ¼ãƒªã‚¨ã•ã‚“</title>
    {% load static %}
    <script src="{% static 'js/vendor/chartjs/chart.min.js' %}"></script>
    <script src="{% static 'js/vendor/chartjs/chartjs-plugin-zoom.min.js' %}"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #a8dadc 0%, #d4f1f4 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 10px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
        }

        .header-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            margin: 0;
            font-size: 24px;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .header-buttons input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4da8da 0%, #73c5e3 100%);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            border: none;
            font-size: 14px;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(77, 168, 218, 0.4);
        }

        .chart-wrapper {
            margin-top: 20px;
        }

        .chart-main {
            display: flex;
            gap: 5px;
        }

        .chart-y-scrollbar-container {
            display: none;
            align-items: center;
            width: 20px;
        }

        .chart-y-scrollbar {
            writing-mode: vertical-lr;
            direction: rtl;
            width: 20px;
            height: 600px;
            cursor: pointer;
        }

        .chart-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .chart-container {
            position: relative;
            height: 600px;
        }

        .chart-container canvas {
            position: relative;
            z-index: 1000;
        }

        .chart-x-scrollbar-container {
            display: none;
            justify-content: center;
            height: 20px;
        }

        .chart-x-scrollbar {
            width: 100%;
            height: 20px;
            cursor: pointer;
        }

        .controls-container {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px 15px;
            border: 2px solid #4da8da;
            border-radius: 8px;
            background: #f0f8ff;
        }

        .legend-threshold-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .legend-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .legend-label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            white-space: nowrap;
        }

        .offset-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .offset-label-text {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        #excludeContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-width: 300px;
            max-height: 80px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 5px;
            border-radius: 4px;
        }

        #excludeContainer label {
            display: flex;
            align-items: center;
            gap: 3px;
            cursor: pointer;
            white-space: nowrap;
            padding: 2px 6px;
            border-radius: 4px;
        }

        #excludeContainer span {
            font-size: 12px;
            font-weight: 500;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        .control-input {
            width: 80px;
            padding: 6px 10px;
            border: 2px solid #4da8da;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .control-input:focus {
            outline: none;
            border-color: #2c8bb8;
        }

        .info-panel {
            background: #fff9e6;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .info-panel h3 {
            color: #f57c00;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .info-panel ul {
            margin-left: 20px;
            color: #666;
            font-size: 13px;
            line-height: 1.6;
        }

        .status-text {
            font-size: 14px;
            color: #666;
            margin-top: 10px;
        }

        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 8px;
            margin-top: 15px;
            height: 30px;
            position: relative;
            display: none;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #4da8da 0%, #73c5e3 100%);
            border-radius: 8px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 13px;
        }

        .file-list-container {
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            gap: 10px;
            align-items: flex-start;
            max-height: 210px;
        }

        .file-item-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 100px;
        }

        .file-name {
            font-size: 12px;
            color: #333;
            font-weight: 500;
            white-space: nowrap;
            height: 16px;
            line-height: 16px;
            width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }


        .offset-input {
            width: 80px;
            padding: 6px 10px;
            border: 2px solid #4da8da;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .offset-input:focus {
            outline: none;
            border-color: #2c8bb8;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="header-wrapper">
                <h1>ãƒ•ãƒ¼ãƒªã‚¨ã•ã‚“</h1>
                <div class="header-buttons">
                    <input type="file" id="audioInput" accept="audio/*" multiple>
                    <label for="audioInput" class="file-input-label">
                        éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠï¼ˆè¤‡æ•°å¯ï¼‰
                    </label>
                    <button id="exportCsvBtn" class="file-input-label" style="display: none;">
                        CSVå‡ºåŠ›
                    </button>
                </div>
            </div>

            <div class="controls-container" style="display: none;" id="controlsContainer">
                <!-- å‡¡ä¾‹è¨­å®š -->
                <div class="legend-threshold-wrapper">
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <div class="legend-checkbox-wrapper">
                            <input type="checkbox" id="legendCheckbox" class="legend-checkbox">
                            <label for="legendCheckbox" class="legend-label">å‡¡ä¾‹</label>
                        </div>
                        <div class="legend-checkbox-wrapper">
                            <input type="checkbox" id="tooltipSingleCheckbox" class="legend-checkbox">
                            <label for="tooltipSingleCheckbox" class="legend-label">å‡¡ä¾‹(å˜ä½“)</label>
                        </div>
                    </div>
                    <div class="offset-section">
                        <span class="offset-label-text" style="min-width: 120px;">ç§»å‹•å¹³å‡:</span>
                        <input type="number" id="smoothWindow" class="offset-input" value="10" min="1" max="100" step="1" placeholder="ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦" style="width: 80px;">
                    </div>
                    <div class="offset-section">
                        <span class="offset-label-text" style="min-width: 120px;">æ™‚é–“åˆ»ã¿ (ç§’):</span>
                        <input type="number" id="timeInterval" class="offset-input" value="0.2" min="0.01" max="10" step="0.01" style="width: 80px;">
                    </div>
                    <div class="offset-section">
                        <span class="offset-label-text" style="min-width: 120px;">æ¨ªç§»å‹•é€Ÿåº¦:</span>
                        <input type="number" id="panSpeedX" class="offset-input" value="0.1" min="0.1" max="100" step="0.1" style="width: 80px;">
                    </div>
                    <div class="offset-section">
                        <span class="offset-label-text" style="min-width: 120px;">ç¸¦ç§»å‹•é€Ÿåº¦:</span>
                        <input type="number" id="panSpeedY" class="offset-input" value="0.001" min="0.001" max="1" step="0.001" style="width: 80px;">
                    </div>
                </div>

                <!-- ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨­å®š -->
                <div id="offsetSection" class="offset-section">
                    <span class="offset-label-text">ã‚ªãƒ•ã‚»ãƒƒãƒˆ:</span>
                    <div id="fileListContainer" class="file-list-container"></div>
                </div>

                <!-- é™¤å¤–è¨­å®š -->
                <div class="offset-section">
                    <span class="offset-label-text">é™¤å¤–:</span>
                    <div id="excludeContainer"></div>
                </div>
                <div class="offset-section">
                    <span class="offset-label-text" style="min-width: 120px;">ãƒ‘ãƒ¯ãƒ¼è¨ˆç®—æ–¹æ³•:</span>
                    <select id="powerCalculationMode" class="offset-input" style="width: 100px;">
                        <option value="sum">åˆè¨ˆ</option>
                        <option value="average">å¹³å‡</option>
                    </select>
                </div>

                <!-- å‘¨æ³¢æ•°å¸¯å†è¨­å®š -->
                <div class="offset-section">
                    <span class="offset-label-text">å‘¨æ³¢æ•°å¸¯:</span>
                    <div style="display: flex; flex-direction: column; gap: 5px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="text" id="freqVeryLowLabel" class="offset-input" value="è¶…ä½åŸŸ" style="width: 80px; font-size: 12px; font-weight: 500;">
                            <input type="number" id="freqVeryLowMin" class="offset-input" value="500" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">ã€œ</span>
                            <input type="number" id="freqVeryLowMax" class="offset-input" value="1000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">Hz</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="text" id="freqLowLabel" class="offset-input" value="ä½åŸŸ" style="width: 80px; font-size: 12px; font-weight: 500;">
                            <input type="number" id="freqLowMin" class="offset-input" value="1000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">ã€œ</span>
                            <input type="number" id="freqLowMax" class="offset-input" value="2000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">Hz</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="text" id="freqMidLabel" class="offset-input" value="ä¸­åŸŸ" style="width: 80px; font-size: 12px; font-weight: 500;">
                            <input type="number" id="freqMidMin" class="offset-input" value="2000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">ã€œ</span>
                            <input type="number" id="freqMidMax" class="offset-input" value="4000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">Hz</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="text" id="freqHighMidLabel" class="offset-input" value="ä¸­é«˜åŸŸ" style="width: 80px; font-size: 12px; font-weight: 500;">
                            <input type="number" id="freqHighMidMin" class="offset-input" value="4000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">ã€œ</span>
                            <input type="number" id="freqHighMidMax" class="offset-input" value="7000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">Hz</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="text" id="freqHighLabel" class="offset-input" value="é«˜åŸŸ" style="width: 80px; font-size: 12px; font-weight: 500;">
                            <input type="number" id="freqHighMin" class="offset-input" value="7000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">ã€œ</span>
                            <input type="number" id="freqHighMax" class="offset-input" value="10000" min="0" max="20000" step="100" style="width: 90px;">
                            <span style="font-size: 12px;">Hz</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ã‚°ãƒ©ãƒ•è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
            <div class="chart-wrapper">
                <div class="chart-main">
                    <div class="chart-y-scrollbar-container">
                        <input type="range" id="yScrollbar" class="chart-y-scrollbar" orient="vertical" min="0" max="100" value="50">
                    </div>
                    <div class="chart-content">
                        <div class="chart-container" id="chartContainer">
                            <canvas id="myChart"></canvas>
                        </div>
                        <div class="chart-x-scrollbar-container">
                            <input type="range" id="xScrollbar" class="chart-x-scrollbar" min="0" max="100" value="50">
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- æ™‚é–“é ˜åŸŸçµ±è¨ˆé‡ã‚«ãƒ¼ãƒ‰ -->
        <div class="card" id="timeStatsCard" style="display: none; margin-top: 20px;">
            <div class="header-wrapper">
                <h1>æ™‚é–“é ˜åŸŸçµ±è¨ˆé‡ï¼ˆç•°å¸¸æ¤œçŸ¥æŒ‡æ¨™ï¼‰</h1>
                <div class="header-buttons">
                    <label style="font-size: 14px; font-weight: 600; color: #333; margin-right: 10px;">è¡¨ç¤ºè¨­å®š:</label>
                    <label style="display: flex; align-items: center; gap: 5px; margin-right: 10px;">
                        <input type="checkbox" id="showCrestFactor" checked>
                        <span style="font-size: 12px;">ã‚¯ãƒ¬ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin-right: 10px;">
                        <input type="checkbox" id="showKurtosis" checked>
                        <span style="font-size: 12px;">å°–åº¦</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="showPeak" checked>
                        <span style="font-size: 12px;">ãƒ”ãƒ¼ã‚¯å€¤</span>
                    </label>
                </div>
            </div>

            <!-- æŒ‡æ¨™ã®èª¬æ˜ -->
            <div style="background: #f0f8ff; border: 2px solid #4da8da; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h3 style="color: #2c8bb8; font-size: 14px; margin-bottom: 10px; font-weight: 600;">ğŸ“Š å„æŒ‡æ¨™ã®è¦‹æ–¹</h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; font-size: 12px;">
                    <div>
                        <strong style="color: #2563eb;">ã‚¯ãƒ¬ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼</strong>
                        <div style="font-size: 11px; color: #666; margin: 3px 0; font-style: italic;">
                            éŸ³ã®ã€Œå°–ã‚Šå…·åˆã€ã€‚ç¬é–“çš„ãªè¡æ’ƒéŸ³ã®å¤§ãã•ã‚’ç¤ºã™ã€‚
                        </div>
                        <div style="font-size: 10px; background: #e8f4f8; padding: 4px 6px; border-radius: 3px; margin: 3px 0; font-family: monospace;">
                            <strong>è¨ˆç®—å¼:</strong> CF = ãƒ”ãƒ¼ã‚¯å€¤ Ã· RMS
                        </div>
                        <ul style="margin: 5px 0 0 15px; padding: 0; line-height: 1.6;">
                            <li><strong>æ­£å¸¸:</strong> 2ã€œ4ï¼ˆå®‰å®šã—ãŸå€¤ï¼‰</li>
                            <li><strong>è¦æ³¨æ„:</strong> 5ä»¥ä¸Š</li>
                            <li><strong>ç•°å¸¸:</strong> 7ä»¥ä¸Š</li>
                            <li style="color: #c00; font-weight: 600;">â†’ ãƒ“ãƒ“ã‚ŠæŒ¯å‹•ãƒ»å·¥å…·æŠ˜æ</li>
                        </ul>
                        <div style="font-size: 10px; color: #555; margin-top: 5px; background: #fff; padding: 5px; border-radius: 4px;">
                            <strong>è¦‹æ–¹:</strong> æ€¥ã«è·³ã­ä¸ŠãŒã‚‹â†’è¡æ’ƒéŸ³ç™ºç”Ÿã€å…¨ä½“çš„ã«é«˜ã„â†’å¸¸ã«ä¸å®‰å®šï¼ˆãƒ“ãƒ“ã‚Šï¼‰
                        </div>
                    </div>
                    <div>
                        <strong style="color: #2563eb;">å°–åº¦</strong>
                        <div style="font-size: 11px; color: #666; margin: 3px 0; font-style: italic;">
                            éŸ³ã®ã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹æ€§ï¼ˆè¡æ’ƒæ€§ï¼‰ã€‚è¦å‰‡çš„ãªè¡æ’ƒéŸ³ã®å¤šã•ã‚’ç¤ºã™ã€‚
                        </div>
                        <div style="font-size: 10px; background: #e8f4f8; padding: 4px 6px; border-radius: 3px; margin: 3px 0; font-family: monospace;">
                            <strong>è¨ˆç®—å¼:</strong> K = Î£[(x-Î¼)/Ïƒ]â´ / N<br>
                            <span style="font-size: 9px;">â€»Î¼=å¹³å‡, Ïƒ=æ¨™æº–åå·®, N=ãƒ‡ãƒ¼ã‚¿æ•°</span>
                        </div>
                        <ul style="margin: 5px 0 0 15px; padding: 0; line-height: 1.6;">
                            <li><strong>æ­£å¸¸:</strong> ç´„3ï¼ˆæ­£è¦åˆ†å¸ƒï¼‰</li>
                            <li><strong>è»½åº¦:</strong> 3ã€œ5ï¼ˆåˆæœŸå…†å€™ï¼‰</li>
                            <li><strong>ä¸­åº¦:</strong> 5ã€œ10ï¼ˆè¦å¯¾å¿œï¼‰</li>
                            <li><strong>é‡åº¦:</strong> 10ä»¥ä¸Šï¼ˆç·Šæ€¥ï¼‰</li>
                            <li style="color: #c00; font-weight: 600;">â†’ ãƒ™ã‚¢ãƒªãƒ³ã‚°ç•°å¸¸ï¼ˆæœ€é‡è¦ï¼‰</li>
                        </ul>
                        <div style="font-size: 10px; color: #555; margin-top: 5px; background: #fff; padding: 5px; border-radius: 4px;">
                            <strong>è¦‹æ–¹:</strong> å¾ã€…ã«ä¸Šæ˜‡â†’åŠ£åŒ–é€²è¡Œä¸­ã€æ€¥ä¸Šæ˜‡â†’ç ´æå¯¸å‰ã€‚ãƒ™ã‚¢ãƒªãƒ³ã‚°äºˆå…†æ¤œå‡ºã«æœ€é©ã€‚
                        </div>
                    </div>
                    <div>
                        <strong style="color: #2563eb;">ãƒ”ãƒ¼ã‚¯å€¤</strong>
                        <div style="font-size: 11px; color: #666; margin: 3px 0; font-style: italic;">
                            éŸ³ã®æœ€å¤§æŒ¯å¹…ã€‚çªç™ºçš„ãªã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¤œå‡ºã€‚
                        </div>
                        <div style="font-size: 10px; background: #e8f4f8; padding: 4px 6px; border-radius: 3px; margin: 3px 0; font-family: monospace;">
                            <strong>è¨ˆç®—å¼:</strong> Peak = max(|x|)<br>
                            <span style="font-size: 9px;">â€»æ™‚é–“çª“å†…ã®çµ¶å¯¾å€¤ã®æœ€å¤§å€¤</span>
                        </div>
                        <ul style="margin: 5px 0 0 15px; padding: 0; line-height: 1.6;">
                            <li><strong>æ­£å¸¸:</strong> 0.1ã€œ0.3ï¼ˆå®‰å®šï¼‰</li>
                            <li><strong>ç•°å¸¸:</strong> 0.5ä»¥ä¸Š</li>
                            <li style="color: #c00; font-weight: 600;">â†’ å·¥å…·ç ´æãƒ»çªç™ºè¡æ’ƒ</li>
                            <li style="color: #666; font-style: italic;">ç¬é–“çš„ãªã‚¹ãƒ‘ã‚¤ã‚¯ã«æ³¨ç›®</li>
                        </ul>
                        <div style="font-size: 10px; color: #555; margin-top: 5px; background: #fff; padding: 5px; border-radius: 4px;">
                            <strong>è¦‹æ–¹:</strong> ç¬é–“çš„ã«è·³ã­ä¸ŠãŒã‚‹â†’æŠ˜æãƒ»è¡çªã€å…¨ä½“çš„ã«é«˜ã„â†’è² è·éå¤§
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart-wrapper">
                <div class="chart-container" id="timeStatsContainer" style="height: 500px;">
                    <canvas id="timeStatsCanvas"></canvas>
                </div>
            </div>

            <!-- ç•°å¸¸æ¤œçŸ¥ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º -->
            <div id="anomalyAlertContainer" style="margin-top: 15px; display: none;">
                <div style="background: #fee; border: 2px solid #f00; border-radius: 8px; padding: 15px;">
                    <h3 style="color: #c00; font-size: 16px; margin-bottom: 10px;">âš ï¸ ç•°å¸¸æ¤œçŸ¥</h3>
                    <div id="anomalyAlertContent" style="font-size: 13px; color: #666;"></div>
                </div>
            </div>
        </div>

        <!-- ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—åˆ†æã‚«ãƒ¼ãƒ‰ -->
        <div class="card" id="envelopeCard" style="display: none; margin-top: 20px;">
            <div class="header-wrapper">
                <h1>ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—åˆ†æï¼ˆãƒ™ã‚¢ãƒªãƒ³ã‚°ç•°å¸¸æ¤œçŸ¥ï¼‰</h1>
                <div class="header-buttons">
                    <label style="font-size: 14px; font-weight: 600; color: #333; margin-right: 10px;">é«˜å‘¨æ³¢å¸¯åŸŸ (5-10kHz) ã®æŒ¯å¹…å¤‰èª¿</label>
                </div>
            </div>

            <!-- ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—åˆ†æã®èª¬æ˜ -->
            <div style="background: #fff9e6; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <div>
                    <strong style="color: #2563eb;">ã‚°ãƒ©ãƒ•ã®è¦‹æ–¹</strong>
                    <table style="width: 100%; font-size: 11px; margin-top: 5px; border-collapse: collapse;">
                        <tr style="background: #f0f0f0;">
                            <th style="padding: 4px; border: 1px solid #ddd; text-align: left;">çŠ¶æ…‹</th>
                            <th style="padding: 4px; border: 1px solid #ddd;">æŒ¯å¹…ãƒ¬ãƒ™ãƒ«</th>
                            <th style="padding: 4px; border: 1px solid #ddd;">ãƒ‘ã‚¿ãƒ¼ãƒ³</th>
                            <th style="padding: 4px; border: 1px solid #ddd;">åˆ¤å®š</th>
                        </tr>
                        <tr>
                            <td style="padding: 4px; border: 1px solid #ddd;"><strong>æ­£å¸¸</strong></td>
                            <td style="padding: 4px; border: 1px solid #ddd;">0.001ã€œ0.005</td>
                            <td style="padding: 4px; border: 1px solid #ddd;">ä½ãå®‰å®š</td>
                            <td style="padding: 4px; border: 1px solid #ddd; color: #080;">âœ“ æ­£å¸¸</td>
                        </tr>
                        <tr style="background: #fffacd;">
                            <td style="padding: 4px; border: 1px solid #ddd;"><strong>åˆæœŸç•°å¸¸</strong></td>
                            <td style="padding: 4px; border: 1px solid #ddd;">0.005ã€œ0.01</td>
                            <td style="padding: 4px; border: 1px solid #ddd;">ã‚ãšã‹ã«å¢—åŠ </td>
                            <td style="padding: 4px; border: 1px solid #ddd; color: #f90;">âš  è¦ç›£è¦–</td>
                        </tr>
                        <tr style="background: #ffe8e8;">
                            <td style="padding: 4px; border: 1px solid #ddd;"><strong>ä¸­åº¦ç•°å¸¸</strong></td>
                            <td style="padding: 4px; border: 1px solid #ddd;">0.01ã€œ0.05</td>
                            <td style="padding: 4px; border: 1px solid #ddd;">æ˜ç¢ºã«å¢—åŠ </td>
                            <td style="padding: 4px; border: 1px solid #ddd; color: #f00;">âš  è¦å¯¾å¿œ</td>
                        </tr>
                        <tr style="background: #fdd;">
                            <td style="padding: 4px; border: 1px solid #ddd;"><strong>é‡åº¦ç•°å¸¸</strong></td>
                            <td style="padding: 4px; border: 1px solid #ddd;">0.05ä»¥ä¸Š</td>
                            <td style="padding: 4px; border: 1px solid #ddd;">å¤§ããä¸è¦å‰‡</td>
                            <td style="padding: 4px; border: 1px solid #ddd; color: #c00; font-weight: bold;">âœ• ç·Šæ€¥</td>
                        </tr>
                    </table>
                </div>
            </div>

            <div class="chart-wrapper">
                <div class="chart-container" id="envelopeContainer" style="height: 400px;">
                    <canvas id="envelopeCanvas"></canvas>
                </div>
            </div>
        </div>

        <!-- ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚«ãƒ¼ãƒ‰ -->
        <div class="card" id="spectrogramCard" style="display: none; margin-top: 20px;">
            <div class="header-wrapper">
                <h1>ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ </h1>
                <div class="header-buttons">
                    <label style="font-size: 14px; font-weight: 600; color: #333; margin-right: 10px;">ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ:</label>
                    <select id="spectrogramFileSelect" class="offset-input" style="width: 200px; font-size: 14px;">
                    </select>
                </div>
            </div>

            <div class="chart-wrapper">
                <div class="chart-container" id="spectrogramContainer" style="height: 400px;">
                    <canvas id="spectrogramCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å®šæ•°å®šç¾©
        const AUDIO_CONFIG = {
            FFT_SIZE: 2048,  // ãƒãƒ©ãƒ³ã‚¹é‡è¦–: å‘¨æ³¢æ•°åˆ†è§£èƒ½23.4Hzï¼ˆç•°å¸¸æ¤œçŸ¥ã«ååˆ†ï¼‰
            FFT_SIZE_SPECTROGRAM: 2048,
            DEFAULT_SMOOTH_WINDOW: 10,
            DEFAULT_TIME_INTERVAL: 0.2,
            MAX_DATA_POINTS: 400,  // ãƒãƒ©ãƒ³ã‚¹é‡è¦–: 3åˆ†ã§0.45ç§’ã”ã¨ï¼ˆé€Ÿåº¦ã¨ç²¾åº¦ã®ãƒãƒ©ãƒ³ã‚¹ï¼‰
            BATCH_SIZE: 50,
            ASYNC_DELAY: 0,
            CHART_HEIGHT: 600,
            SCROLLBAR_SIZE: 20,
            COLOR_ALPHA_BACKGROUND: 0.6,
            COLOR_ALPHA_BORDER: 1.0,
            COLOR_ALPHA_LABEL: 0.2,
            RGB_MAX: 255,
            RGB_MIN: 0
        };

        const FREQUENCY_CONFIG = {
            MIN_FREQ_SPECTROGRAM: 500,
            MAX_FREQ_SPECTROGRAM: 10000,
            DYNAMIC_RANGE_DB: 60
        };

        const ANOMALY_THRESHOLDS = {
            CREST_FACTOR: 5.0,
            KURTOSIS: 3.0,
            PEAK: 0.5
        };

        const SCROLL_TOLERANCE = 0.001;
        const SCROLL_PERCENT_MAX = 100;
        const SCROLL_PERCENT_MIN = 0;
        const DEBOUNCE_DELAY = 500; // ãƒ‡ãƒã‚¦ãƒ³ã‚¹é…å»¶æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰

        let chart = null;
        let audioContext = null;
        let uploadedFiles = [];
        let fileOffsets = new Map();
        let fftSize = AUDIO_CONFIG.FFT_SIZE;
        let smoothWindow = AUDIO_CONFIG.DEFAULT_SMOOTH_WINDOW;
        let timeInterval = AUDIO_CONFIG.DEFAULT_TIME_INTERVAL;
        let powerCalculationMode = 'sum';
        let excludedBands = [];
        let excludedFiles = [];
        let debounceTimer = null; // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ç”¨ã‚¿ã‚¤ãƒãƒ¼

        let timeStatsDataMap = new Map();
        let envelopeDataMap = new Map();
        let showTimeStats = true;
        let showEnvelope = true;
        let anomalyThresholds = {
            crestFactor: ANOMALY_THRESHOLDS.CREST_FACTOR,
            kurtosis: ANOMALY_THRESHOLDS.KURTOSIS,
            peak: ANOMALY_THRESHOLDS.PEAK
        };

        // Hammingçª“ä¿‚æ•°ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆäº‹å‰è¨ˆç®—ã§é«˜é€ŸåŒ–ï¼‰
        let hammingWindowCache = new Map();

        // å‘¨æ³¢æ•°å¸¯è¨­å®šï¼ˆå‹•çš„ã«å¤‰æ›´å¯èƒ½ï¼‰
        let freqBandRanges = {
            verylow: { min: 500, max: 1000, label: 'è¶…ä½åŸŸ' },
            low: { min: 1000, max: 2000, label: 'ä½åŸŸ' },
            mid: { min: 2000, max: 4000, label: 'ä¸­åŸŸ' },
            highmid: { min: 4000, max: 7000, label: 'ä¸­é«˜åŸŸ' },
            high: { min: 7000, max: 10000, label: 'é«˜åŸŸ' }
        };

        // UIè¨­å®š
        let tooltipEnabled = false;
        let tooltipSingleMode = false; // å‡¡ä¾‹(å˜ä½“)ãƒ¢ãƒ¼ãƒ‰
        let spectrogramDataMap = new Map(); // ãƒ•ã‚¡ã‚¤ãƒ«å -> ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ãƒ‡ãƒ¼ã‚¿

        // ãƒ‘ãƒ³ãƒ»ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ç”¨å¤‰æ•°
        let isScrollbarUpdating = false;
        const keysPressed = {
            ArrowRight: false,
            ArrowLeft: false,
            ArrowUp: false,
            ArrowDown: false
        };
        let animationFrameId = null;

        // DOMè¦ç´ ã®å–å¾—
        const elements = {
            audioInput: document.getElementById('audioInput'),
            exportCsvBtn: document.getElementById('exportCsvBtn'),
            spectrogramCard: document.getElementById('spectrogramCard'),
            spectrogramFileSelect: document.getElementById('spectrogramFileSelect'),
            spectrogramContainer: document.getElementById('spectrogramContainer'),
            spectrogramCanvas: document.getElementById('spectrogramCanvas'),
            controlsContainer: document.getElementById('controlsContainer'),
            fileListContainer: document.getElementById('fileListContainer'),
            excludeContainer: document.getElementById('excludeContainer'),
            legendCheckbox: document.getElementById('legendCheckbox'),
            tooltipSingleCheckbox: document.getElementById('tooltipSingleCheckbox'),
            smoothWindow: document.getElementById('smoothWindow'),
            timeInterval: document.getElementById('timeInterval'),
            powerCalculationMode: document.getElementById('powerCalculationMode'),
            panSpeedX: document.getElementById('panSpeedX'),
            panSpeedY: document.getElementById('panSpeedY'),
            xScrollbar: document.getElementById('xScrollbar'),
            yScrollbar: document.getElementById('yScrollbar'),
            // å‘¨æ³¢æ•°å¸¯è¨­å®š
            freqVeryLowLabel: document.getElementById('freqVeryLowLabel'),
            freqVeryLowMin: document.getElementById('freqVeryLowMin'),
            freqVeryLowMax: document.getElementById('freqVeryLowMax'),
            freqLowLabel: document.getElementById('freqLowLabel'),
            freqLowMin: document.getElementById('freqLowMin'),
            freqLowMax: document.getElementById('freqLowMax'),
            freqMidLabel: document.getElementById('freqMidLabel'),
            freqMidMin: document.getElementById('freqMidMin'),
            freqMidMax: document.getElementById('freqMidMax'),
            freqHighMidLabel: document.getElementById('freqHighMidLabel'),
            freqHighMidMin: document.getElementById('freqHighMidMin'),
            freqHighMidMax: document.getElementById('freqHighMidMax'),
            freqHighLabel: document.getElementById('freqHighLabel'),
            freqHighMin: document.getElementById('freqHighMin'),
            freqHighMax: document.getElementById('freqHighMax')
        };

        // å‘¨æ³¢æ•°å¸¯åŸŸã”ã¨ã®åŸºæœ¬è‰²å®šç¾©
        const bandBaseColors = {
            'verylow': [127, 29, 29],    // æš—ã„èµ¤
            'low': [220, 38, 38],        // èµ¤
            'mid': [251, 146, 60],       // ã‚ªãƒ¬ãƒ³ã‚¸
            'highmid': [250, 204, 21],   // é»„è‰²
            'high': [134, 239, 172]      // æ˜ã‚‹ã„ç·‘
        };

        // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã®æ˜åº¦èª¿æ•´ä¿‚æ•°ï¼ˆåŒç³»çµ±ã®ç•°ãªã‚‹è‰²ã«ã™ã‚‹ï¼‰
        const fileColorVariants = [
            1.0,   // ã‚ªãƒªã‚¸ãƒŠãƒ«
            0.7,   // æš—ã‚
            1.3,   // æ˜ã‚‹ã‚
            0.5,   // ã‚ˆã‚Šæš—ã‚
            1.5,   // ã‚ˆã‚Šæ˜ã‚‹ã‚
            0.85,  // å°‘ã—æš—ã‚
            1.15,  // å°‘ã—æ˜ã‚‹ã‚
            0.6    // ä¸­é–“æš—ã‚
        ];

        // RGBå€¤ã‚’èª¿æ•´ã—ã¦åŒç³»çµ±ã®è‰²ã‚’ç”Ÿæˆ
        function adjustColor(rgb, factor) {
            return [
                Math.min(AUDIO_CONFIG.RGB_MAX, Math.max(AUDIO_CONFIG.RGB_MIN, Math.round(rgb[0] * factor))),
                Math.min(AUDIO_CONFIG.RGB_MAX, Math.max(AUDIO_CONFIG.RGB_MIN, Math.round(rgb[1] * factor))),
                Math.min(AUDIO_CONFIG.RGB_MAX, Math.max(AUDIO_CONFIG.RGB_MIN, Math.round(rgb[2] * factor)))
            ];
        }

        // RGBé…åˆ—ã‚’rgbaæ–‡å­—åˆ—ã«å¤‰æ›
        function rgbArrayToRgba(rgb, alpha) {
            return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
        }

        // RGBé…åˆ—ã‚’rgbæ–‡å­—åˆ—ã«å¤‰æ›
        function rgbArrayToRgb(rgb) {
            return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        }

        // RGBæ–‡å­—åˆ—ã‚’RGBAæ–‡å­—åˆ—ã«å¤‰æ›
        function rgbStringToRgba(rgbString, alpha) {
            return rgbString.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ãŒé™¤å¤–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function isFileExcluded(fileName) {
            return excludedFiles.includes(fileName);
        }

        // å¸¯åŸŸãŒé™¤å¤–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function isBandExcluded(bandKey) {
            return excludedBands.includes(bandKey);
        }

        // ãƒ‡ãƒ¼ã‚¿ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
        function applyDataOffset(data, offset) {
            if (offset === 0) return data;
            return data.map(point => ({ x: point.x + offset, y: point.y }));
        }

        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ï¼šé€£ç¶šã—ãŸå…¥åŠ›ã‚’é…å»¶å®Ÿè¡Œ
        function debounceAnalysis() {
            if (debounceTimer) {
                clearTimeout(debounceTimer);
            }
            debounceTimer = setTimeout(async () => {
                if (uploadedFiles.length > 0) {
                    await analyzeAllAudio();
                    setTimeout(() => {
                        renderTimeStatsChart();
                        renderEnvelopeChart();
                    }, AUDIO_CONFIG.ASYNC_DELAY);
                }
            }, DEBOUNCE_DELAY);
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã®è‰²å®šç¾©ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆè¡¨ç¤ºç”¨ï¼‰
        const fileColors = [
            'rgb(37, 99, 235)',   // é’
            'rgb(220, 38, 38)',   // èµ¤
            'rgb(251, 146, 60)',  // ã‚ªãƒ¬ãƒ³ã‚¸
            'rgb(34, 197, 94)',   // ç·‘
            'rgb(168, 85, 247)',  // ç´«
            'rgb(236, 72, 153)',  // ãƒ”ãƒ³ã‚¯
            'rgb(14, 165, 233)',  // æ°´è‰²
            'rgb(234, 179, 8)'    // é»„è‰²
        ];

        // ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’è¡¨ç¤ºï¼ˆã‚ªãƒ•ã‚»ãƒƒãƒˆå…¥åŠ›ä»˜ãï¼‰
        function displayFileList(files) {
            elements.fileListContainer.innerHTML = '';

            files.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item-control';

                const fileName = document.createElement('span');
                fileName.className = 'file-name';
                fileName.textContent = file.name;

                const offsetInput = document.createElement('input');
                offsetInput.type = 'number';
                offsetInput.className = 'offset-input';
                offsetInput.value = fileOffsets.get(file.name) || 0;
                offsetInput.step = '0.1';
                offsetInput.placeholder = 'ä½ç½®è£œæ­£';
                offsetInput.dataset.fileName = file.name;

                offsetInput.addEventListener('input', (e) => {
                    const offset = parseFloat(e.target.value) || 0;
                    fileOffsets.set(file.name, offset);
                    debounceAnalysis();
                });

                fileItem.appendChild(fileName);
                fileItem.appendChild(offsetInput);
                elements.fileListContainer.appendChild(fileItem);
            });
        }

        // é™¤å¤–ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
        function updateExcludeCheckboxes() {
            elements.excludeContainer.innerHTML = '';

            const freqBands = {
                'verylow': { label: `${freqBandRanges.verylow.label} (${freqBandRanges.verylow.min}-${freqBandRanges.verylow.max}Hz)`, color: [127, 29, 29] },
                'low': { label: `${freqBandRanges.low.label} (${freqBandRanges.low.min}-${freqBandRanges.low.max}Hz)`, color: [220, 38, 38] },
                'mid': { label: `${freqBandRanges.mid.label} (${freqBandRanges.mid.min}-${freqBandRanges.mid.max}Hz)`, color: [251, 146, 60] },
                'highmid': { label: `${freqBandRanges.highmid.label} (${freqBandRanges.highmid.min}-${freqBandRanges.highmid.max}Hz)`, color: [250, 204, 21] },
                'high': { label: `${freqBandRanges.high.label} (${freqBandRanges.high.min}-${freqBandRanges.high.max}Hz)`, color: [134, 239, 172] },
                'rms': { label: 'RMSæŒ¯å¹…', color: [37, 99, 235] }
            };

            // å‘¨æ³¢æ•°å¸¯åŸŸã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
            Object.keys(freqBands).forEach(bandKey => {
                const band = freqBands[bandKey];
                const label = createExcludeLabel(bandKey, band.label, band.color, true);
                elements.excludeContainer.appendChild(label);
            });

            // ãƒ•ã‚¡ã‚¤ãƒ«åã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
            uploadedFiles.forEach((file, index) => {
                const color = fileColors[index % fileColors.length];
                const rgb = color.match(/\d+/g).map(Number);
                const label = createExcludeLabel(file.name, file.name, rgb, false);
                elements.excludeContainer.appendChild(label);
            });
        }

        // é™¤å¤–ãƒ©ãƒ™ãƒ«ã‚’ä½œæˆ
        function createExcludeLabel(value, displayName, color, isBand) {
            const label = document.createElement('label');
            label.style.backgroundColor = rgbArrayToRgba(color, AUDIO_CONFIG.COLOR_ALPHA_LABEL);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = value;
            checkbox.checked = isBand
                ? excludedBands.includes(value)
                : excludedFiles.includes(value);

            checkbox.addEventListener('change', async (e) => {
                const targetArray = isBand ? excludedBands : excludedFiles;
                if (e.target.checked) {
                    if (!targetArray.includes(value)) targetArray.push(value);
                } else {
                    const index = targetArray.indexOf(value);
                    if (index > -1) targetArray.splice(index, 1);
                }
                await analyzeAllAudio();
            });

            const span = document.createElement('span');
            span.textContent = displayName;

            label.appendChild(checkbox);
            label.appendChild(span);
            return label;
        }

        // å‡¡ä¾‹ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
        elements.legendCheckbox.addEventListener('change', async (e) => {
            if (e.target.checked) {
                tooltipEnabled = true;
                tooltipSingleMode = false;
                elements.tooltipSingleCheckbox.checked = false;
            } else {
                tooltipEnabled = false;
            }
            if (uploadedFiles.length > 0) {
                await analyzeAllAudio();
                setTimeout(() => {
                    renderTimeStatsChart();
                    renderEnvelopeChart();
                }, AUDIO_CONFIG.ASYNC_DELAY);
            }
        });

        // å‡¡ä¾‹(å˜ä½“)ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
        elements.tooltipSingleCheckbox.addEventListener('change', async (e) => {
            if (e.target.checked) {
                tooltipEnabled = true;
                tooltipSingleMode = true;
                elements.legendCheckbox.checked = false;
            } else {
                tooltipEnabled = false;
                tooltipSingleMode = false;
            }
            if (uploadedFiles.length > 0) {
                await analyzeAllAudio();
                setTimeout(() => {
                    renderTimeStatsChart();
                    renderEnvelopeChart();
                }, AUDIO_CONFIG.ASYNC_DELAY);
            }
        });

        // å¹³æ»‘åŒ–ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®å¤‰æ›´ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
        elements.smoothWindow.addEventListener('input', (e) => {
            smoothWindow = parseInt(e.target.value) || 1;
            debounceAnalysis();
        });

        // æ™‚é–“åˆ»ã¿ã®å¤‰æ›´ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
        elements.timeInterval.addEventListener('input', (e) => {
            timeInterval = parseFloat(e.target.value) || 0.1;
            debounceAnalysis();
        });

        // ãƒ‘ãƒ¯ãƒ¼è¨ˆç®—æ–¹æ³•ã®å¤‰æ›´ï¼ˆå³åº§ã«å®Ÿè¡Œï¼‰
        elements.powerCalculationMode.addEventListener('change', async (e) => {
            powerCalculationMode = e.target.value;
            if (uploadedFiles.length > 0) {
                await analyzeAllAudio();
            }
        });

        // å‘¨æ³¢æ•°å¸¯è¨­å®šã®å¤‰æ›´
        const freqInputs = [
            { band: 'verylow', label: elements.freqVeryLowLabel, min: elements.freqVeryLowMin, max: elements.freqVeryLowMax },
            { band: 'low', label: elements.freqLowLabel, min: elements.freqLowMin, max: elements.freqLowMax },
            { band: 'mid', label: elements.freqMidLabel, min: elements.freqMidMin, max: elements.freqMidMax },
            { band: 'highmid', label: elements.freqHighMidLabel, min: elements.freqHighMidMin, max: elements.freqHighMidMax },
            { band: 'high', label: elements.freqHighLabel, min: elements.freqHighMin, max: elements.freqHighMax }
        ];

        freqInputs.forEach(({ band, label, min, max }) => {
            label.addEventListener('input', (e) => {
                freqBandRanges[band].label = e.target.value || '';
                if (uploadedFiles.length > 0) {
                    updateExcludeCheckboxes();
                    debounceAnalysis();
                }
            });
            min.addEventListener('input', (e) => {
                freqBandRanges[band].min = parseFloat(e.target.value) || 0;
                if (uploadedFiles.length > 0) {
                    updateExcludeCheckboxes();
                    debounceAnalysis();
                }
            });
            max.addEventListener('input', (e) => {
                freqBandRanges[band].max = parseFloat(e.target.value) || 0;
                if (uploadedFiles.length > 0) {
                    updateExcludeCheckboxes();
                    debounceAnalysis();
                }
            });
        });

        // CSVå‡ºåŠ›
        elements.exportCsvBtn.addEventListener('click', () => {
            if (chart) exportChartDataToCsv();
        });

        // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
        elements.spectrogramFileSelect.addEventListener('change', (e) => {
            const fileName = e.target.value;
            const data = spectrogramDataMap.get(fileName);
            if (data) {
                renderSpectrogram(data);
            }
        });

        // CSVå‡ºåŠ›é–¢æ•°
        function exportChartDataToCsv() {
            if (!chart || !chart.data.datasets || chart.data.datasets.length === 0) {
                alert('å‡ºåŠ›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            const datasets = chart.data.datasets;
            const xScale = chart.scales.x;
            const minX = Math.floor(xScale.min);
            const maxX = Math.ceil(xScale.max);

            // è¡¨ç¤ºç¯„å›²å†…ã®Xåº§æ¨™ã‚’åé›†
            const xValues = new Set();
            datasets.forEach(dataset => {
                if (dataset.data && Array.isArray(dataset.data)) {
                    dataset.data.forEach(point => {
                        if (point && typeof point === 'object' && point.x >= minX && point.x <= maxX) {
                            xValues.add(point.x);
                        }
                    });
                }
            });

            const sortedX = Array.from(xValues).sort((a, b) => a - b);

            if (sortedX.length === 0) {
                alert('è¡¨ç¤ºç¯„å›²å†…ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // CSVãƒ˜ãƒƒãƒ€ãƒ¼
            let csvContent = 'æ™‚åˆ»(ç§’)';
            datasets.forEach(dataset => {
                const columnName = dataset.label.split(' - ')[1] || dataset.label;
                csvContent += ',' + columnName;
            });
            csvContent += '\n';

            // ãƒ‡ãƒ¼ã‚¿è¡Œ
            sortedX.forEach(x => {
                csvContent += x;
                datasets.forEach(dataset => {
                    const point = dataset.data.find(p => p && p.x === x);
                    const value = point ? point.y : '';
                    csvContent += ',' + value;
                });
                csvContent += '\n';
            });

            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            const now = new Date();
            const timestamp = now.getFullYear() +
                String(now.getMonth() + 1).padStart(2, '0') +
                String(now.getDate()).padStart(2, '0') + '_' +
                String(now.getHours()).padStart(2, '0') +
                String(now.getMinutes()).padStart(2, '0') +
                String(now.getSeconds()).padStart(2, '0');
            const filename = `audio_analysis_${timestamp}.csv`;

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼æ›´æ–°é–¢æ•°
        function updateScrollbarsFromChart() {
            if (!chart || isScrollbarUpdating) return;

            isScrollbarUpdating = true;

            const xScale = chart.scales.x;
            const yScale = chart.scales.y;
            const xLimits = chart.options.plugins.zoom.limits.x;
            const yLimits = chart.options.plugins.zoom.limits.y;

            const xScrollbarContainer = document.querySelector('.chart-x-scrollbar-container');
            const yScrollbarContainer = document.querySelector('.chart-y-scrollbar-container');

            if (xScale && xLimits) {
                const xViewRange = xScale.max - xScale.min;
                const xScrollableRange = (xLimits.max - xLimits.min) - xViewRange;

                if (xScrollableRange > SCROLL_TOLERANCE) {
                    xScrollbarContainer.style.display = 'flex';
                    const xPosition = ((xScale.min - xLimits.min) / xScrollableRange) * SCROLL_PERCENT_MAX;
                    xScrollbar.value = Math.max(SCROLL_PERCENT_MIN, Math.min(SCROLL_PERCENT_MAX, xPosition));
                } else {
                    xScrollbarContainer.style.display = 'none';
                    xScrollbar.value = SCROLL_PERCENT_MIN;
                }
            }

            if (yScale && yLimits) {
                const yViewRange = yScale.max - yScale.min;
                const yScrollableRange = (yLimits.max - yLimits.min) - yViewRange;

                if (yScrollableRange > SCROLL_TOLERANCE) {
                    yScrollbarContainer.style.display = 'flex';
                    const yPosition = ((yScale.min - yLimits.min) / yScrollableRange) * SCROLL_PERCENT_MAX;
                    yScrollbar.value = Math.max(SCROLL_PERCENT_MIN, Math.min(SCROLL_PERCENT_MAX, yPosition));
                } else {
                    yScrollbarContainer.style.display = 'none';
                    yScrollbar.value = SCROLL_PERCENT_MIN;
                }
            }

            isScrollbarUpdating = false;
        }

        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‹ã‚‰ãƒ‘ãƒ³
        function panFromScrollbar(axis, scrollValue) {
            if (!chart || isScrollbarUpdating) return;

            const scale = chart.scales[axis];
            const limits = chart.options.plugins.zoom.limits[axis];

            if (!scale || !limits) return;

            const viewRange = scale.max - scale.min;
            const scrollableRange = (limits.max - limits.min) - viewRange;

            const newMin = limits.min + (scrollableRange * scrollValue / SCROLL_PERCENT_MAX);
            const newMax = newMin + viewRange;

            const clampedMin = Math.max(limits.min, Math.min(limits.max - viewRange, newMin));
            const clampedMax = clampedMin + viewRange;

            chart.scales[axis].options.min = clampedMin;
            chart.scales[axis].options.max = clampedMax;

            // Yè»¸ã®å ´åˆã¯ç¬¬2è»¸ï¼ˆy2ï¼‰ã‚‚ä¸€ç·’ã«ç§»å‹•
            if (axis === 'y' && chart.scales.y2) {
                const y2Scale = chart.scales.y2;
                const y2Limits = chart.options.plugins.zoom.limits.y2;

                if (y2Limits) {
                    const y2ViewRange = y2Scale.max - y2Scale.min;
                    const y2ScrollableRange = (y2Limits.max - y2Limits.min) - y2ViewRange;

                    const y2NewMin = y2Limits.min + (y2ScrollableRange * scrollValue / SCROLL_PERCENT_MAX);
                    const y2NewMax = y2NewMin + y2ViewRange;

                    const y2ClampedMin = Math.max(y2Limits.min, Math.min(y2Limits.max - y2ViewRange, y2NewMin));
                    const y2ClampedMax = y2ClampedMin + y2ViewRange;

                    chart.scales.y2.options.min = y2ClampedMin;
                    chart.scales.y2.options.max = y2ClampedMax;
                }
            }

            chart.update('none');

            updateScrollbarsFromChart();
        }

        // è»¸ã‚’ãƒ‘ãƒ³
        function panAxis(axis, delta) {
            if (!chart || !chart.scales[axis]) return;

            const scale = chart.scales[axis];
            const limits = chart.options.plugins.zoom.limits[axis];
            if (!limits) return;

            const currentRange = scale.max - scale.min;

            // æ–°ã—ã„min/maxã‚’è¨ˆç®—
            let newMin = scale.min + delta;
            let newMax = scale.max + delta;

            // ç¯„å›²ã‚’åˆ¶é™å†…ã«åã‚ã‚‹
            if (newMin < limits.min) {
                newMin = limits.min;
                newMax = limits.min + currentRange;
            }
            if (newMax > limits.max) {
                newMax = limits.max;
                newMin = limits.max - currentRange;
            }

            // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ›´æ–°
            chart.scales[axis].options.min = newMin;
            chart.scales[axis].options.max = newMax;

            // Yè»¸ã®å ´åˆã¯ç¬¬2è»¸ï¼ˆy2ï¼‰ã‚‚ä¸€ç·’ã«ç§»å‹•
            if (axis === 'y' && chart.scales.y2) {
                const y2Scale = chart.scales.y2;
                const y2Limits = chart.options.plugins.zoom.limits.y2;

                if (y2Limits) {
                    const y2CurrentRange = y2Scale.max - y2Scale.min;
                    let y2NewMin = y2Scale.min + delta;
                    let y2NewMax = y2Scale.max + delta;

                    // ç¯„å›²ã‚’åˆ¶é™å†…ã«åã‚ã‚‹
                    if (y2NewMin < y2Limits.min) {
                        y2NewMin = y2Limits.min;
                        y2NewMax = y2Limits.min + y2CurrentRange;
                    }
                    if (y2NewMax > y2Limits.max) {
                        y2NewMax = y2Limits.max;
                        y2NewMin = y2Limits.max - y2CurrentRange;
                    }

                    chart.scales.y2.options.min = y2NewMin;
                    chart.scales.y2.options.max = y2NewMax;
                }
            }

            chart.update('none');

            updateScrollbarsFromChart();
        }

        // é€£ç¶šãƒ‘ãƒ³
        function continuousPan() {
            if (!chart) return;

            const speedX = parseFloat(elements.panSpeedX.value) || 5;
            const speedY = parseFloat(elements.panSpeedY.value) || 0.05;

            if (keysPressed.ArrowRight) panAxis('x', speedX);
            if (keysPressed.ArrowLeft) panAxis('x', -speedX);
            if (keysPressed.ArrowUp) panAxis('y', speedY);
            if (keysPressed.ArrowDown) panAxis('y', -speedY);

            if (keysPressed.ArrowRight || keysPressed.ArrowLeft ||
                keysPressed.ArrowUp || keysPressed.ArrowDown) {
                animationFrameId = requestAnimationFrame(continuousPan);
            }
        }

        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
        elements.xScrollbar.addEventListener('input', (e) => {
            if (!chart) return;
            panFromScrollbar('x', parseFloat(e.target.value));
        });

        elements.yScrollbar.addEventListener('input', (e) => {
            if (!chart) return;
            panFromScrollbar('y', parseFloat(e.target.value));
        });

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ
        document.addEventListener('keydown', (e) => {
            if (!chart) return;

            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒã‚ã‚‹å ´åˆã¯çŸ¢å°ã‚­ãƒ¼ã‚’ç„¡åŠ¹åŒ–
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
                return;
            }

            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft' ||
                e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();

                if (!keysPressed[e.key]) {
                    keysPressed[e.key] = true;
                    if (!animationFrameId) {
                        continuousPan();
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒã‚ã‚‹å ´åˆã¯çŸ¢å°ã‚­ãƒ¼ã‚’ç„¡åŠ¹åŒ–
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
                return;
            }

            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft' ||
                e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                keysPressed[e.key] = false;

                if (!keysPressed.ArrowRight && !keysPressed.ArrowLeft &&
                    !keysPressed.ArrowUp && !keysPressed.ArrowDown) {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                }
            }
        });

        // éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
        elements.audioInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            uploadedFiles = files;
            fileOffsets.clear();
            files.forEach(file => fileOffsets.set(file.name, 0));

            try {
                // AudioContextã®åˆæœŸåŒ–
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
                displayFileList(files);

                // é™¤å¤–ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
                updateExcludeCheckboxes();

                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’è¡¨ç¤º
                elements.controlsContainer.style.display = 'flex';

                // ãƒ¡ã‚¤ãƒ³ã®ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚°ãƒ©ãƒ•ã‚’æœ€å„ªå…ˆã§è¡¨ç¤º
                await analyzeAllAudio();

                // æ™‚é–“é ˜åŸŸçµ±è¨ˆé‡ã¨ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—åˆ†æã‚’éåŒæœŸã§æç”»
                setTimeout(() => {
                    renderTimeStatsChart();
                    renderEnvelopeChart();
                    detectAnomalies();
                }, AUDIO_CONFIG.ASYNC_DELAY);

                // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚’éåŒæœŸã§è¨ˆç®—ï¼ˆé‡ã„å‡¦ç†ï¼‰
                setTimeout(async () => {
                    await calculateAllSpectrograms();
                }, AUDIO_CONFIG.ASYNC_DELAY);

            } catch (error) {
                console.error('éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        });

        // å…¨éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æã™ã‚‹é–¢æ•°ï¼ˆè¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œãƒ»ä¸¦åˆ—å‡¦ç†ï¼‰
        async function analyzeAllAudio() {
            if (uploadedFiles.length === 0) return;

            const allBandDataMap = new Map();
            const allRmsData = new Map();
            let maxDuration = 0;

            // ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚’ä¸¦åˆ—åŒ–ï¼ˆPromise.allï¼‰
            const filePromises = uploadedFiles.map(async (file) => {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    const result = await analyzeAudio(audioBuffer);

                    return {
                        fileName: file.name,
                        bandDataMap: result.bandDataMap,
                        rmsData: result.rmsData,
                        duration: result.duration,
                        // é…å»¶è¨ˆç®—ç”¨ã®ãƒ‡ãƒ¼ã‚¿
                        _channelData: result._channelData,
                        _sampleRate: result._sampleRate,
                        _numTimePoints: result._numTimePoints,
                        _actualTimeInterval: result._actualTimeInterval
                    };
                } catch (error) {
                    console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${file.name} ã®è§£æã‚¨ãƒ©ãƒ¼:`, error);
                    return null;
                }
            });

            const results = await Promise.all(filePromises);

            // çµæœã‚’é›†ç´„
            results.forEach(result => {
                if (result) {
                    allBandDataMap.set(result.fileName, result.bandDataMap);
                    allRmsData.set(result.fileName, result.rmsData);

                    if (result.duration > maxDuration) {
                        maxDuration = result.duration;
                    }

                    // æ™‚é–“é ˜åŸŸçµ±è¨ˆé‡ã¨ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ã¯å¾Œã§è¨ˆç®—ï¼ˆéåŒæœŸï¼‰
                    setTimeout(() => {
                        const timeStatsData = calculateTimeStats(
                            result._channelData,
                            result._sampleRate,
                            result._numTimePoints,
                            result._actualTimeInterval
                        );
                        const envelopeData = calculateEnvelope(
                            result._channelData,
                            result._sampleRate,
                            result._numTimePoints,
                            result._actualTimeInterval
                        );
                        timeStatsDataMap.set(result.fileName, timeStatsData);
                        envelopeDataMap.set(result.fileName, envelopeData);
                    }, AUDIO_CONFIG.ASYNC_DELAY);
                }
            });

            // ã‚°ãƒ©ãƒ•ã‚’æç”»ï¼ˆãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚°ãƒ©ãƒ•ã®ã¿ï¼‰
            renderChartMultiFile(allBandDataMap, allRmsData, maxDuration);
        }

        // éŸ³å£°ã‚’è§£æã™ã‚‹é–¢æ•°ï¼ˆé•·æ™‚é–“ãƒ‡ãƒ¼ã‚¿å¯¾å¿œç‰ˆï¼‰
        async function analyzeAudio(audioBuffer) {
            if (!audioBuffer) return;

            // ãƒãƒ£ãƒ³ãƒãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆãƒ¢ãƒãƒ©ãƒ«ã«å¤‰æ›ï¼‰
            const channelData = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const duration = audioBuffer.duration;

            // å‘¨æ³¢æ•°å¸¯åŸŸã®è¨­å®šï¼ˆæ©Ÿæ¢°åŠ å·¥ã®ç•°å¸¸æ¤œçŸ¥ã«æœ€é©åŒ–ï¼‰
            // å‘¨æ³¢æ•°ãŒä¸ŠãŒã‚‹ã”ã¨ã«æš—ã„è‰²â†’æ˜ã‚‹ã„è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            const freqBands = {
                all: { min: 500, max: 10000, label: 'å…¨å¸¯åŸŸ (500Hz-10kHz)', color: 'rgb(37, 99, 235)' },
                verylow: { min: freqBandRanges.verylow.min, max: freqBandRanges.verylow.max, label: `${freqBandRanges.verylow.label} (${freqBandRanges.verylow.min}-${freqBandRanges.verylow.max}Hz): ãƒ™ã‚¢ãƒªãƒ³ã‚°æ‘©è€—`, color: 'rgb(127, 29, 29)' }, // æš—ã„èµ¤
                low: { min: freqBandRanges.low.min, max: freqBandRanges.low.max, label: `${freqBandRanges.low.label} (${freqBandRanges.low.min}-${freqBandRanges.low.max}Hz): å·¥å…·æ‘©è€—`, color: 'rgb(220, 38, 38)' }, // èµ¤
                mid: { min: freqBandRanges.mid.min, max: freqBandRanges.mid.max, label: `${freqBandRanges.mid.label} (${freqBandRanges.mid.min}-${freqBandRanges.mid.max}Hz): åˆ‡å‰Šç•°å¸¸`, color: 'rgb(251, 146, 60)' }, // ã‚ªãƒ¬ãƒ³ã‚¸
                highmid: { min: freqBandRanges.highmid.min, max: freqBandRanges.highmid.max, label: `${freqBandRanges.highmid.label} (${freqBandRanges.highmid.min}-${freqBandRanges.highmid.max}Hz): ãƒ“ãƒ“ãƒªæŒ¯å‹•`, color: 'rgb(250, 204, 21)' }, // é»„è‰²
                high: { min: freqBandRanges.high.min, max: freqBandRanges.high.max, label: `${freqBandRanges.high.label} (${freqBandRanges.high.min}-${freqBandRanges.high.max}Hz): å·¥å…·ç ´æ`, color: 'rgb(134, 239, 172)' } // æ˜ã‚‹ã„ç·‘
            };

            // è©³ç´°åˆ†æç”¨ã®å¸¯åŸŸãƒªã‚¹ãƒˆ
            const multiBands = ['verylow', 'low', 'mid', 'highmid', 'high'];

            // é•·æ™‚é–“ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯è‡ªå‹•çš„ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆé«˜é€ŸåŒ–ï¼‰
            let actualTimeInterval = timeInterval;
            const maxDataPoints = AUDIO_CONFIG.MAX_DATA_POINTS;
            let numTimePoints = Math.floor(duration / actualTimeInterval);

            if (numTimePoints > maxDataPoints) {
                actualTimeInterval = duration / maxDataPoints;
                numTimePoints = maxDataPoints;
            }

            // è©³ç´°åˆ†æãƒ¢ãƒ¼ãƒ‰: 5ã¤ã®å¸¯åŸŸãã‚Œãã‚Œã‚’è¿½è·¡
            let bandDataMap = new Map();
            const batchSize = AUDIO_CONFIG.BATCH_SIZE;

            // é…åˆ—ã‚’äº‹å‰ç¢ºä¿ï¼ˆpushä¸è¦ã§é«˜é€ŸåŒ–ï¼‰
            multiBands.forEach(bandKey => {
                bandDataMap.set(bandKey, new Array(numTimePoints));
            });

            // å‘¨æ³¢æ•°ãƒ“ãƒ³ã‚’äº‹å‰è¨ˆç®—ï¼ˆãƒ«ãƒ¼ãƒ—å†…ã§ç¹°ã‚Šè¿”ã—è¨ˆç®—ã—ãªã„ï¼‰
            const bandBins = {};
            multiBands.forEach(bandKey => {
                const band = freqBands[bandKey];
                bandBins[bandKey] = {
                    min: Math.floor(band.min * fftSize / sampleRate),
                    max: Math.floor(band.max * fftSize / sampleRate)
                };
            });

            // FFTå‡¦ç†ã‚’ä¸€æ‹¬å®Ÿè¡Œï¼ˆãƒãƒƒãƒå¾…æ©Ÿãªã— - é«˜é€ŸåŒ–ï¼‰
            for (let i = 0; i < numTimePoints; i++) {
                const currentTime = i * actualTimeInterval;
                const startSample = Math.floor(currentTime * sampleRate);

                if (startSample + fftSize > channelData.length) break;

                // ã“ã®æ™‚é–“ã®å‘¨è¾ºãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã—ã¦FFT
                const frame = channelData.slice(startSample, startSample + fftSize);
                const windowedFrame = applyHammingWindow(frame);

                // FFTã‚’å®Ÿè¡Œï¼ˆé«˜é€Ÿç‰ˆï¼‰- 1å›ã®FFTã§å…¨å‘¨æ³¢æ•°ã‚’å–å¾—
                const fftResult = performFFTFast(windowedFrame);

                // å„å¸¯åŸŸã®ãƒ‘ãƒ¯ãƒ¼ã‚’è¨ˆç®—ï¼ˆäº‹å‰è¨ˆç®—ã—ãŸãƒ“ãƒ³ã‚’ä½¿ç”¨ã€ç›´æ¥ä»£å…¥ï¼‰
                bandDataMap.forEach((dataArray, bandKey) => {
                    const bins = bandBins[bandKey];
                    let power = 0;
                    for (let j = bins.min; j < bins.max && j < fftResult.length; j++) {
                        power += fftResult[j];
                    }

                    // ãƒ‘ãƒ¯ãƒ¼è¨ˆç®—æ–¹æ³•ã«å¿œã˜ã¦å‡¦ç†
                    if (powerCalculationMode === 'average') {
                        power = power / (bins.max - bins.min);
                    }

                    dataArray[i] = { x: currentTime, y: power };  // pushâ†’ç›´æ¥ä»£å…¥ã§é«˜é€ŸåŒ–
                });
            }

            // ç§»å‹•å¹³å‡ã§ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆéåŒæœŸã§å®Ÿè¡Œã—ã¦é«˜é€ŸåŒ–ï¼‰
            const smoothedBandData = new Map();
            bandDataMap.forEach((dataArray, bandKey) => {
                smoothedBandData.set(bandKey, applyMovingAverage(dataArray, smoothWindow));
            });

            // RMSè¨ˆç®—ã‚’ç°¡ç•¥åŒ–ï¼šFFTãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰è¨ˆç®—ï¼ˆé…åˆ—äº‹å‰ç¢ºä¿ï¼‰
            const rmsData = new Array(numTimePoints);
            for (let i = 0; i < numTimePoints; i++) {
                const currentTime = i * actualTimeInterval;
                const startSample = Math.floor(currentTime * sampleRate);

                if (startSample + fftSize > channelData.length) break;

                // FFTã¨åŒã˜ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½¿ç”¨ã—ã¦RMSè¨ˆç®—ï¼ˆé«˜é€ŸåŒ–ï¼‰
                const frame = channelData.slice(startSample, startSample + fftSize);
                let sumSquares = 0;
                for (let j = 0; j < frame.length; j++) {
                    sumSquares += frame[j] * frame[j];
                }
                const rms = Math.sqrt(sumSquares / frame.length);
                rmsData[i] = { x: currentTime, y: rms };  // pushâ†’ç›´æ¥ä»£å…¥
            }

            // ãƒ¡ã‚¤ãƒ³ã‚°ãƒ©ãƒ•è¡¨ç¤ºã‚’é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã€é‡ã„è¨ˆç®—ã¯é…å»¶å®Ÿè¡Œ
            // æ™‚é–“é ˜åŸŸçµ±è¨ˆé‡ã¨ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ã¯åˆ¥é€”è¨ˆç®—
            const timeStatsData = null;
            const envelopeData = null;

            // çµæœã‚’è¿”ã™ï¼ˆchannelDataã‚‚ä¿æŒã—ã¦å¾Œã§è¨ˆç®—ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼‰
            return {
                bandDataMap: smoothedBandData,
                rmsData: rmsData,
                timeStatsData: timeStatsData,
                envelopeData: envelopeData,
                duration: duration,
                // å¾Œã§çµ±è¨ˆé‡è¨ˆç®—ã«ä½¿ç”¨
                _channelData: channelData,
                _sampleRate: sampleRate,
                _numTimePoints: numTimePoints,
                _actualTimeInterval: actualTimeInterval
            };
        }

        // ===========================
        // æ–°æ©Ÿèƒ½1: æ™‚é–“é ˜åŸŸçµ±è¨ˆé‡ã®è¨ˆç®—
        // ===========================
        function calculateTimeStats(channelData, sampleRate, numTimePoints, timeInterval) {
            const crestFactorData = [];
            const kurtosisData = [];
            const peakData = [];

            for (let i = 0; i < numTimePoints; i++) {
                const currentTime = i * timeInterval;
                const startSample = Math.floor(currentTime * sampleRate);
                const endSample = Math.floor((currentTime + timeInterval) * sampleRate);

                if (endSample > channelData.length) break;

                const window = channelData.slice(startSample, endSample);
                if (window.length === 0) continue;

                // RMSï¼ˆå®ŸåŠ¹å€¤ï¼‰
                const rms = Math.sqrt(window.reduce((sum, val) => sum + val * val, 0) / window.length);

                // ãƒ”ãƒ¼ã‚¯å€¤ï¼ˆçµ¶å¯¾å€¤ã®æœ€å¤§ï¼‰- æœ€é©åŒ–ç‰ˆ
                let peak = 0;
                for (let j = 0; j < window.length; j++) {
                    const absVal = Math.abs(window[j]);
                    if (absVal > peak) peak = absVal;
                }

                // ã‚¯ãƒ¬ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ = ãƒ”ãƒ¼ã‚¯å€¤ / RMS
                const crestFactor = rms > 0 ? peak / rms : 0;

                // å°–åº¦ (Kurtosis) - æœ€é©åŒ–ç‰ˆ
                const mean = window.reduce((sum, val) => sum + val, 0) / window.length;
                const variance = window.reduce((sum, val) => {
                    const diff = val - mean;
                    return sum + diff * diff;  // Math.pow(diff, 2)ã‚ˆã‚Šé«˜é€Ÿ
                }, 0) / window.length;
                const stdDev = Math.sqrt(variance);

                let kurtosis = 0;
                if (stdDev > 0) {
                    const fourthMoment = window.reduce((sum, val) => {
                        const z = (val - mean) / stdDev;
                        return sum + z * z * z * z;  // Math.pow(z, 4)ã‚ˆã‚Šé«˜é€Ÿ
                    }, 0) / window.length;
                    kurtosis = fourthMoment;
                }

                crestFactorData.push({ x: currentTime, y: crestFactor });
                kurtosisData.push({ x: currentTime, y: kurtosis });
                peakData.push({ x: currentTime, y: peak });
            }

            return {
                crestFactor: crestFactorData,
                kurtosis: kurtosisData,
                peak: peakData
            };
        }

        // ===========================
        // æ–°æ©Ÿèƒ½2: ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—åˆ†æï¼ˆãƒ’ãƒ«ãƒ™ãƒ«ãƒˆå¤‰æ›ï¼‰
        // ===========================
        function calculateEnvelope(channelData, sampleRate, numTimePoints, timeInterval) {
            // é«˜å‘¨æ³¢å¸¯åŸŸï¼ˆ5kHz-10kHzï¼‰ã‚’ãƒãƒ³ãƒ‰ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿
            const filteredData = bandpassFilter(channelData, sampleRate, 5000, 10000);

            // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ã‚’è¨ˆç®—ï¼ˆç§»å‹•å¹³å‡ã«ã‚ˆã‚‹ç°¡æ˜“ç‰ˆï¼‰
            const envelopeData = [];
            const envelopeFFTData = [];

            for (let i = 0; i < numTimePoints; i++) {
                const currentTime = i * timeInterval;
                const startSample = Math.floor(currentTime * sampleRate);
                const endSample = Math.floor((currentTime + timeInterval) * sampleRate);

                if (endSample > filteredData.length) break;

                const window = filteredData.slice(startSample, endSample);
                if (window.length === 0) continue;

                // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ— = çµ¶å¯¾å€¤ã®ç§»å‹•å¹³å‡
                const envelope = window.reduce((sum, val) => sum + Math.abs(val), 0) / window.length;
                envelopeData.push({ x: currentTime, y: envelope });
            }

            return {
                envelope: envelopeData
            };
        }

        // ãƒãƒ³ãƒ‰ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆç°¡æ˜“ç‰ˆï¼šFFTãƒ™ãƒ¼ã‚¹ï¼‰
        function bandpassFilter(data, sampleRate, lowFreq, highFreq) {
            const N = data.length;

            // FFTã‚µã‚¤ã‚ºã‚’2ã®ç´¯ä¹—ã«èª¿æ•´
            let fftSizeFilter = 1;
            while (fftSizeFilter < N) {
                fftSizeFilter *= 2;
            }

            // ã‚¼ãƒ­ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
            const paddedData = new Float32Array(fftSizeFilter);
            paddedData.set(data);

            // FFTå®Ÿè¡Œ
            const real = new Float32Array(paddedData);
            const imag = new Float32Array(fftSizeFilter);
            fftRadix2(real, imag);

            // ãƒãƒ³ãƒ‰ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿é©ç”¨
            const lowBin = Math.floor(lowFreq * fftSizeFilter / sampleRate);
            const highBin = Math.floor(highFreq * fftSizeFilter / sampleRate);

            for (let i = 0; i < fftSizeFilter; i++) {
                if (i < lowBin || i > highBin) {
                    if (i < fftSizeFilter / 2 || i > fftSizeFilter - lowBin) {
                        real[i] = 0;
                        imag[i] = 0;
                    }
                }
            }

            // é€†FFT
            for (let i = 0; i < fftSizeFilter; i++) {
                imag[i] = -imag[i];
            }
            fftRadix2(real, imag);
            for (let i = 0; i < fftSizeFilter; i++) {
                real[i] /= fftSizeFilter;
            }

            // å…ƒã®ã‚µã‚¤ã‚ºã«æˆ»ã™
            return real.slice(0, N);
        }

        // ãƒãƒŸãƒ³ã‚°çª“ã‚’é©ç”¨ï¼ˆä¿‚æ•°ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦é«˜é€ŸåŒ–ï¼‰
        function applyHammingWindow(frame) {
            const N = frame.length;

            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ä¿‚æ•°ã‚’å–å¾—ã€ãªã‘ã‚Œã°è¨ˆç®—
            let windowCoeffs = hammingWindowCache.get(N);
            if (!windowCoeffs) {
                windowCoeffs = new Float32Array(N);
                for (let i = 0; i < N; i++) {
                    windowCoeffs[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (N - 1));
                }
                hammingWindowCache.set(N, windowCoeffs);
            }

            // ä¿‚æ•°ã‚’é©ç”¨
            const windowed = new Float32Array(N);
            for (let i = 0; i < N; i++) {
                windowed[i] = frame[i] * windowCoeffs[i];
            }
            return windowed;
        }

        // FFTã‚’å®Ÿè¡Œï¼ˆé«˜é€Ÿç‰ˆ - Cooley-Tukey FFTã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰
        function performFFTFast(frame) {
            const N = frame.length;

            // NãŒ2ã®ç´¯ä¹—ã§ãªã„å ´åˆã¯å¾“æ¥ç‰ˆã‚’ä½¿ç”¨
            if ((N & (N - 1)) !== 0) {
                return performFFTSlow(frame);
            }

            // è¤‡ç´ æ•°é…åˆ—ã‚’ä½œæˆ
            const real = new Float32Array(N);
            const imag = new Float32Array(N);

            for (let i = 0; i < N; i++) {
                real[i] = frame[i];
                imag[i] = 0;
            }

            // Cooley-Tukey FFTã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆRadix-2 DITï¼‰
            fftRadix2(real, imag);

            // ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰ã‚’è¨ˆç®—
            const magnitude = new Float32Array(N / 2);
            for (let i = 0; i < N / 2; i++) {
                magnitude[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / N;
            }

            return magnitude;
        }

        // Cooley-Tukey FFTï¼ˆRadix-2 Decimation-In-Timeï¼‰
        function fftRadix2(real, imag) {
            const N = real.length;

            // ãƒ“ãƒƒãƒˆåè»¢ä¸¦ã³æ›¿ãˆ
            let j = 0;
            for (let i = 0; i < N - 1; i++) {
                if (i < j) {
                    [real[i], real[j]] = [real[j], real[i]];
                    [imag[i], imag[j]] = [imag[j], imag[i]];
                }
                let k = N >> 1;
                while (k <= j) {
                    j -= k;
                    k >>= 1;
                }
                j += k;
            }

            // ãƒã‚¿ãƒ•ãƒ©ã‚¤æ¼”ç®—
            for (let size = 2; size <= N; size *= 2) {
                const halfSize = size / 2;
                const angle = -2 * Math.PI / size;

                for (let i = 0; i < N; i += size) {
                    for (let j = 0; j < halfSize; j++) {
                        const k = i + j;
                        const l = k + halfSize;

                        const twiddle_real = Math.cos(angle * j);
                        const twiddle_imag = Math.sin(angle * j);

                        const t_real = twiddle_real * real[l] - twiddle_imag * imag[l];
                        const t_imag = twiddle_real * imag[l] + twiddle_imag * real[l];

                        real[l] = real[k] - t_real;
                        imag[l] = imag[k] - t_imag;
                        real[k] += t_real;
                        imag[k] += t_imag;
                    }
                }
            }
        }

        // FFTã‚’å®Ÿè¡Œï¼ˆé…ã„ç‰ˆ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
        function performFFTSlow(frame) {
            const N = frame.length;
            const magnitude = new Float32Array(N / 2);

            // å„å‘¨æ³¢æ•°ãƒ“ãƒ³ã®å¤§ãã•ã‚’è¨ˆç®—
            for (let k = 0; k < N / 2; k++) {
                let real = 0;
                let imag = 0;
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    real += frame[n] * Math.cos(angle);
                    imag += frame[n] * Math.sin(angle);
                }
                magnitude[k] = Math.sqrt(real * real + imag * imag) / N;
            }
            return magnitude;
        }

        // ç§»å‹•å¹³å‡ã§ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
        // æœ€é©åŒ–ç‰ˆç§»å‹•å¹³å‡ï¼ˆã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼‰
        function applyMovingAverage(data, windowSize) {
            if (windowSize <= 1) return data;

            const smoothed = new Array(data.length);
            const halfWindow = Math.floor(windowSize / 2);

            // åˆæœŸã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®åˆè¨ˆã‚’è¨ˆç®—
            let sum = 0;
            let count = 0;
            const start = 0;
            const end = Math.min(data.length, halfWindow + 1);
            for (let j = start; j < end; j++) {
                sum += data[j].y;
                count++;
            }
            smoothed[0] = { x: data[0].x, y: sum / count };

            // ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§é«˜é€Ÿè¨ˆç®—
            for (let i = 1; i < data.length; i++) {
                const leftIdx = i - halfWindow - 1;
                const rightIdx = i + halfWindow;

                // å·¦ç«¯ã‚’å‰Šé™¤
                if (leftIdx >= 0) {
                    sum -= data[leftIdx].y;
                    count--;
                }
                // å³ç«¯ã‚’è¿½åŠ 
                if (rightIdx < data.length) {
                    sum += data[rightIdx].y;
                    count++;
                }

                smoothed[i] = { x: data[i].x, y: sum / count };
            }
            return smoothed;
        }


        // ã‚°ãƒ©ãƒ•ã‚’æç”»ï¼ˆè¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œç‰ˆï¼‰
        function renderChartMultiFile(allBandDataMap, allRmsData, maxDuration) {
            const ctx = document.getElementById('myChart').getContext('2d');

            if (chart) {
                chart.destroy();
            }

            const datasets = [];
            const freqBands = {
                verylow: { min: freqBandRanges.verylow.min, max: freqBandRanges.verylow.max, label: `${freqBandRanges.verylow.label} (${freqBandRanges.verylow.min}-${freqBandRanges.verylow.max}Hz)`, color: 'rgb(127, 29, 29)' },
                low: { min: freqBandRanges.low.min, max: freqBandRanges.low.max, label: `${freqBandRanges.low.label} (${freqBandRanges.low.min}-${freqBandRanges.low.max}Hz)`, color: 'rgb(220, 38, 38)' },
                mid: { min: freqBandRanges.mid.min, max: freqBandRanges.mid.max, label: `${freqBandRanges.mid.label} (${freqBandRanges.mid.min}-${freqBandRanges.mid.max}Hz)`, color: 'rgb(251, 146, 60)' },
                highmid: { min: freqBandRanges.highmid.min, max: freqBandRanges.highmid.max, label: `${freqBandRanges.highmid.label} (${freqBandRanges.highmid.min}-${freqBandRanges.highmid.max}Hz)`, color: 'rgb(250, 204, 21)' },
                high: { min: freqBandRanges.high.min, max: freqBandRanges.high.max, label: `${freqBandRanges.high.label} (${freqBandRanges.high.min}-${freqBandRanges.high.max}Hz)`, color: 'rgb(134, 239, 172)' }
            };
            const multiBands = ['verylow', 'low', 'mid', 'highmid', 'high'];

            // å„ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’è¿½åŠ 
            let fileIndex = 0;
            allBandDataMap.forEach((bandDataMap, fileName) => {
                // é™¤å¤–ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—
                if (excludedFiles.includes(fileName)) {
                    fileIndex++;
                    return;
                }

                const colorVariant = fileColorVariants[fileIndex % fileColorVariants.length];
                const offset = fileOffsets.get(fileName) || 0;

                // å„å‘¨æ³¢æ•°å¸¯åŸŸã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ
                multiBands.forEach(bandKey => {
                    // é™¤å¤–ã•ã‚ŒãŸå¸¯åŸŸã¯ã‚¹ã‚­ãƒƒãƒ—
                    if (excludedBands.includes(bandKey)) return;

                    const band = freqBands[bandKey];
                    const bandData = bandDataMap.get(bandKey) || [];
                    const data = applyDataOffset(bandData, offset);

                    // å¸¯åŸŸã®åŸºæœ¬è‰²ã‚’å–å¾—ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«èª¿æ•´
                    const baseColor = bandBaseColors[bandKey];
                    const adjustedColor = adjustColor(baseColor, colorVariant);
                    const colorString = rgbArrayToRgb(adjustedColor);

                    datasets.push({
                        label: `${fileName} - ${band.label}`,
                        data: data,
                        borderColor: colorString,
                        backgroundColor: rgbArrayToRgba(adjustedColor, 0.1),
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.1,
                        fill: false,
                        yAxisID: 'y'
                    });
                });

                fileIndex++;
            });

            // RMSæŒ¯å¹…ãƒ¬ãƒ™ãƒ«ã‚’è¿½åŠ 
            fileIndex = 0;
            const rmsBaseColor = [37, 99, 235]; // é’ç³»
            allRmsData.forEach((rmsData, fileName) => {
                // é™¤å¤–ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯RMSå¸¯åŸŸã¯ã‚¹ã‚­ãƒƒãƒ—
                if (excludedFiles.includes(fileName) || excludedBands.includes('rms')) {
                    fileIndex++;
                    return;
                }

                const colorVariant = fileColorVariants[fileIndex % fileColorVariants.length];
                const adjustedColor = adjustColor(rmsBaseColor, colorVariant);
                const colorString = rgbArrayToRgb(adjustedColor);
                const offset = fileOffsets.get(fileName) || 0;
                const data = applyDataOffset(rmsData, offset);

                datasets.push({
                    label: `${fileName} - RMSæŒ¯å¹…`,
                    data: data,
                    borderColor: colorString,
                    backgroundColor: rgbArrayToRgba(adjustedColor, 0.1),
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0.1,
                    fill: false,
                    yAxisID: 'y2'
                });

                fileIndex++;
            });

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 12,
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            enabled: tooltipEnabled,
                            mode: tooltipSingleMode ? 'nearest' : 'index',
                            intersect: false,
                            axis: tooltipSingleMode ? 'xy' : 'x',
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    if (tooltipSingleMode && context.length > 0) {
                                        return `æ™‚åˆ»: ${context[0].parsed.x.toFixed(3)}ç§’`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    if (tooltipSingleMode) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                    }
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(102, 126, 234, 0.3)',
                                    borderColor: 'rgba(102, 126, 234, 1)',
                                    borderWidth: 2
                                },
                                mode: 'xy',
                                onZoomComplete: function({chart}) {
                                    updateScrollbarsFromChart();
                                }
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                modifierKey: 'shift',
                                onPanComplete: function({chart}) {
                                    updateScrollbarsFromChart();
                                }
                            },
                            limits: {
                                x: { min: 'original', max: 'original' },
                                y: { min: 'original', max: 'original' },
                                y2: { min: 'original', max: 'original' }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: true,
                            title: {
                                display: true,
                                text: 'æ™‚é–“ (ç§’)',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'å‘¨æ³¢æ•°ãƒ‘ãƒ¯ãƒ¼',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y2: {
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'RMSæŒ¯å¹…',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            elements.exportCsvBtn.style.display = 'inline-block';

            // limitsã‚’å®Ÿéš›ã®æ•°å€¤ã«è¨­å®š
            const xScale = chart.scales.x;
            const yScale = chart.scales.y;
            const y2Scale = chart.scales.y2;

            const xRange = xScale.max - xScale.min;
            const yRange = yScale.max - yScale.min;
            const y2Range = y2Scale.max - y2Scale.min;

            chart.options.plugins.zoom.limits.x = {
                min: xScale.min - xRange * 0.1,
                max: xScale.max + xRange * 0.1
            };
            chart.options.plugins.zoom.limits.y = {
                min: yScale.min - yRange * 0.1,
                max: yScale.max + yRange * 0.1
            };
            chart.options.plugins.zoom.limits.y2 = {
                min: y2Scale.min - y2Range * 0.1,
                max: y2Scale.max + y2Range * 0.1
            };

            updateScrollbarsFromChart();
        }

        // ã‚°ãƒ©ãƒ•ã‚’æç”»ï¼ˆè¤‡æ•°å¸¯åŸŸå¯¾å¿œç‰ˆï¼‰
        function renderChartMultiBand(smoothedBandData, rmsData, freqBands, duration) {
            const ctx = document.getElementById('myChart').getContext('2d');

            if (chart) {
                chart.destroy();
            }

            const datasets = [];

            // å„å‘¨æ³¢æ•°å¸¯åŸŸã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’è¿½åŠ 
            smoothedBandData.forEach((data, bandKey) => {
                const band = freqBands[bandKey];
                datasets.push({
                    label: band.label,
                    data: data,
                    borderColor: band.color,
                    backgroundColor: rgbStringToRgba(band.color, 0.1),
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0.1,
                    fill: false,
                    yAxisID: 'y'
                });
            });

            // RMSæŒ¯å¹…ãƒ¬ãƒ™ãƒ«ã‚’è¿½åŠ 
            datasets.push({
                label: 'RMSæŒ¯å¹…ãƒ¬ãƒ™ãƒ«',
                data: rmsData,
                borderColor: 'rgb(37, 99, 235)',
                backgroundColor: 'rgba(37, 99, 235, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                pointHoverRadius: 0,
                tension: 0.1,
                fill: false,
                yAxisID: 'y2'
            });


            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 12,
                                font: { size: 12 }
                            }
                        },
                        tooltip: {
                            enabled: tooltipEnabled,
                            mode: tooltipSingleMode ? 'nearest' : 'index',
                            intersect: false,
                            axis: tooltipSingleMode ? 'xy' : 'x',
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    if (tooltipSingleMode && context.length > 0) {
                                        return `æ™‚åˆ»: ${context[0].parsed.x.toFixed(3)}ç§’`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    if (tooltipSingleMode) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                    }
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(102, 126, 234, 0.3)',
                                    borderColor: 'rgba(102, 126, 234, 1)',
                                    borderWidth: 2
                                },
                                mode: 'xy',
                                onZoomComplete: function({chart}) {
                                    updateScrollbarsFromChart();
                                }
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                modifierKey: 'shift',
                                onPanComplete: function({chart}) {
                                    updateScrollbarsFromChart();
                                }
                            },
                            limits: {
                                x: { min: 'original', max: 'original' },
                                y: { min: 'original', max: 'original' },
                                y2: { min: 'original', max: 'original' }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: true,
                            title: {
                                display: true,
                                text: 'æ™‚é–“ (ç§’)',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'å‘¨æ³¢æ•°ãƒ‘ãƒ¯ãƒ¼',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y2: {
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'RMSæŒ¯å¹…',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            elements.exportCsvBtn.style.display = 'inline-block';

            // limitsã‚’å®Ÿéš›ã®æ•°å€¤ã«è¨­å®šï¼ˆ'original'ã‹ã‚‰å¤‰æ›ï¼‰
            const xScale = chart.scales.x;
            const yScale = chart.scales.y;
            const y2Scale = chart.scales.y2;

            const xRange = xScale.max - xScale.min;
            const yRange = yScale.max - yScale.min;
            const y2Range = y2Scale.max - y2Scale.min;

            chart.options.plugins.zoom.limits.x = {
                min: xScale.min - xRange * 0.1,
                max: xScale.max + xRange * 0.1
            };
            chart.options.plugins.zoom.limits.y = {
                min: yScale.min - yRange * 0.1,
                max: yScale.max + yRange * 0.1
            };
            chart.options.plugins.zoom.limits.y2 = {
                min: y2Scale.min - y2Range * 0.1,
                max: y2Scale.max + y2Range * 0.1
            };

            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’åˆæœŸåŒ–
            updateScrollbarsFromChart();
        }

        // ===========================
        // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ æ©Ÿèƒ½
        // ===========================

        // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
        async function calculateSpectrogram(audioBuffer, fileName) {
            const channelData = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const duration = audioBuffer.duration;

            // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ è¨­å®š
            const fftSizeSpec = AUDIO_CONFIG.FFT_SIZE_SPECTROGRAM;
            const hopSize = Math.floor(fftSizeSpec / 4);
            const numFrames = Math.floor((channelData.length - fftSizeSpec) / hopSize);
            const numFreqBins = fftSizeSpec / 2;

            // å‘¨æ³¢æ•°ç¯„å›²ï¼ˆ500Hz - 10000Hzï¼‰
            const minFreq = FREQUENCY_CONFIG.MIN_FREQ_SPECTROGRAM;
            const maxFreq = FREQUENCY_CONFIG.MAX_FREQ_SPECTROGRAM;
            const minBin = Math.floor(minFreq * fftSizeSpec / sampleRate);
            const maxBin = Math.floor(maxFreq * fftSizeSpec / sampleRate);

            // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´
            const spectrogram = [];
            const timeStamps = [];

            for (let i = 0; i < numFrames; i++) {
                const startSample = i * hopSize;
                const frame = channelData.slice(startSample, startSample + fftSizeSpec);

                if (frame.length < fftSizeSpec) break;

                const windowedFrame = applyHammingWindow(frame);
                const fftResult = performFFTFast(windowedFrame);

                // æŒ‡å®šå‘¨æ³¢æ•°ç¯„å›²ã®ã¿æŠ½å‡º
                const freqSlice = Array.from(fftResult.slice(minBin, maxBin));
                spectrogram.push(freqSlice);
                timeStamps.push(startSample / sampleRate);
            }

            return {
                spectrogram: spectrogram,
                timeStamps: timeStamps,
                freqMin: minFreq,
                freqMax: maxFreq,
                duration: duration,
                fileName: fileName
            };
        }

        // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚’æç”»ã™ã‚‹é–¢æ•°
        function renderSpectrogram(data) {
            const canvas = elements.spectrogramCanvas;
            const ctx = canvas.getContext('2d');

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’è¦ªè¦ç´ ã«åˆã‚ã›ã‚‹
            const container = elements.spectrogramContainer;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // ãƒãƒ¼ã‚¸ãƒ³è¨­å®šï¼ˆè»¸ãƒ©ãƒ™ãƒ«ç”¨ã®ã‚¹ãƒšãƒ¼ã‚¹ï¼‰
            const margin = {
                top: 20,
                right: 20,
                bottom: 40,
                left: 60
            };

            const spectrogram = data.spectrogram;
            const timeStamps = data.timeStamps;
            const numFrames = spectrogram.length;
            const numFreqBins = spectrogram[0].length;

            // å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆdBï¼‰ã«å¤‰æ›
            const spectrogramDB = [];
            for (let i = 0; i < numFrames; i++) {
                spectrogramDB[i] = [];
                for (let j = 0; j < numFreqBins; j++) {
                    // ãƒ‡ã‚·ãƒ™ãƒ«å¤‰æ›: 20 * log10(value)
                    // æœ€å°å€¤ã‚’è¨­å®šã—ã¦-Infinityã‚’é˜²ã
                    const value = Math.max(spectrogram[i][j], 1e-10);
                    const db = 20 * Math.log10(value);
                    spectrogramDB[i][j] = db;
                }
            }

            // dBã®æœ€å¤§å€¤ãƒ»æœ€å°å€¤ã‚’å–å¾—
            let minDB = Infinity;
            let maxDB = -Infinity;
            for (let i = 0; i < numFrames; i++) {
                for (let j = 0; j < numFreqBins; j++) {
                    if (spectrogramDB[i][j] < minDB) minDB = spectrogramDB[i][j];
                    if (spectrogramDB[i][j] > maxDB) maxDB = spectrogramDB[i][j];
                }
            }

            // ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãƒ¬ãƒ³ã‚¸ã‚’åˆ¶é™ï¼ˆè¦‹ã‚„ã™ãã™ã‚‹ãŸã‚ï¼‰
            const dynamicRange = FREQUENCY_CONFIG.DYNAMIC_RANGE_DB;
            const dbMin = maxDB - dynamicRange;

            // æç”»é ˜åŸŸã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
            const plotWidth = canvas.width - margin.left - margin.right;
            const plotHeight = canvas.height - margin.top - margin.bottom;

            // ãƒ”ã‚¯ã‚»ãƒ«ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
            const pixelWidth = plotWidth / numFrames;
            const pixelHeight = plotHeight / numFreqBins;

            // èƒŒæ™¯ã‚’ç™½ã§å¡—ã‚Šã¤ã¶ã—
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚’æç”»ï¼ˆä¸‹ã‹ã‚‰ä¸Šã¸ã€å‘¨æ³¢æ•°ãŒé«˜ã„ã»ã©ä¸Šï¼‰
            for (let i = 0; i < numFrames; i++) {
                for (let j = 0; j < numFreqBins; j++) {
                    const db = spectrogramDB[i][j];
                    // ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãƒ¬ãƒ³ã‚¸å†…ã§æ­£è¦åŒ–
                    const normalized = Math.max(0, Math.min(1, (db - dbMin) / dynamicRange));

                    // ã‚«ãƒ©ãƒ¼ãƒãƒƒãƒ—ï¼ˆé’â†’ç·‘â†’é»„â†’èµ¤ï¼‰
                    const color = getHeatMapColor(normalized);
                    ctx.fillStyle = color;

                    const x = margin.left + i * pixelWidth;
                    const y = margin.top + plotHeight - (j + 1) * pixelHeight; // ä¸‹ã‹ã‚‰ä¸Šã¸

                    ctx.fillRect(x, y, Math.ceil(pixelWidth), Math.ceil(pixelHeight));
                }
            }

            // è»¸ãƒ©ãƒ™ãƒ«ã¨æ ã‚’è¿½åŠ 
            drawSpectrogramAxes(ctx, canvas, data, margin, plotWidth, plotHeight);
        }

        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚«ãƒ©ãƒ¼ã‚’å–å¾—ï¼ˆ0-1ã®å€¤ã‚’è‰²ã«å¤‰æ›ï¼‰
        function getHeatMapColor(value) {
            // é’(0) â†’ ã‚·ã‚¢ãƒ³(0.25) â†’ ç·‘(0.5) â†’ é»„(0.75) â†’ èµ¤(1.0)
            let r, g, b;

            if (value < 0.25) {
                // é’ â†’ ã‚·ã‚¢ãƒ³
                const t = value / 0.25;
                r = 0;
                g = Math.floor(255 * t);
                b = 255;
            } else if (value < 0.5) {
                // ã‚·ã‚¢ãƒ³ â†’ ç·‘
                const t = (value - 0.25) / 0.25;
                r = 0;
                g = 255;
                b = Math.floor(255 * (1 - t));
            } else if (value < 0.75) {
                // ç·‘ â†’ é»„
                const t = (value - 0.5) / 0.25;
                r = Math.floor(255 * t);
                g = 255;
                b = 0;
            } else {
                // é»„ â†’ èµ¤
                const t = (value - 0.75) / 0.25;
                r = 255;
                g = Math.floor(255 * (1 - t));
                b = 0;
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã®è»¸ãƒ©ãƒ™ãƒ«ã‚’æç”»
        function drawSpectrogramAxes(ctx, canvas, data, margin, plotWidth, plotHeight) {
            ctx.fillStyle = '#333';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.font = '12px sans-serif';

            // æ ã‚’æç”»
            ctx.strokeRect(margin.left, margin.top, plotWidth, plotHeight);

            // Xè»¸ãƒ©ãƒ™ãƒ«ï¼ˆæ™‚é–“ï¼‰
            ctx.textAlign = 'center';
            ctx.fillText('æ™‚é–“ (ç§’)', margin.left + plotWidth / 2, canvas.height - 10);

            // Xè»¸ã®ç›®ç››ã‚Šï¼ˆç°¡æ˜“ç‰ˆï¼‰
            const numXTicks = 5;
            ctx.font = '10px sans-serif';
            for (let i = 0; i <= numXTicks; i++) {
                const x = margin.left + (plotWidth * i / numXTicks);
                const time = (data.duration * i / numXTicks).toFixed(1);
                ctx.fillText(time, x, canvas.height - 25);

                // ç›®ç››ã‚Šç·š
                ctx.beginPath();
                ctx.moveTo(x, margin.top + plotHeight);
                ctx.lineTo(x, margin.top + plotHeight + 5);
                ctx.stroke();
            }

            // Yè»¸ãƒ©ãƒ™ãƒ«ï¼ˆå‘¨æ³¢æ•°ï¼‰
            ctx.save();
            ctx.translate(15, margin.top + plotHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.font = '12px sans-serif';
            ctx.fillText('å‘¨æ³¢æ•° (Hz)', 0, 0);
            ctx.restore();

            // Yè»¸ã®ç›®ç››ã‚Š
            const numYTicks = 5;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= numYTicks; i++) {
                const y = margin.top + plotHeight - (plotHeight * i / numYTicks);
                const freq = Math.round(data.freqMin + (data.freqMax - data.freqMin) * i / numYTicks);
                ctx.fillText(freq, margin.left - 10, y + 3);

                // ç›®ç››ã‚Šç·š
                ctx.beginPath();
                ctx.moveTo(margin.left - 5, y);
                ctx.lineTo(margin.left, y);
                ctx.stroke();
            }
        }

        // å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚’è¨ˆç®—
        async function calculateAllSpectrograms() {
            if (uploadedFiles.length === 0) return;

            // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
            spectrogramDataMap.clear();

            // selectã‚’ã‚¯ãƒªã‚¢
            elements.spectrogramFileSelect.innerHTML = '';

            // å„ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚’è¨ˆç®—
            for (let i = 0; i < uploadedFiles.length; i++) {
                const file = uploadedFiles[i];
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    const data = await calculateSpectrogram(audioBuffer, file.name);

                    // ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                    spectrogramDataMap.set(file.name, data);

                    // selectã«è¿½åŠ 
                    const option = document.createElement('option');
                    option.value = file.name;
                    option.textContent = file.name;
                    elements.spectrogramFileSelect.appendChild(option);
                } catch (error) {
                    console.error(`ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ è¨ˆç®—ã‚¨ãƒ©ãƒ¼ (${file.name}):`, error);
                }
            }

            // ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
            if (spectrogramDataMap.size > 0) {
                elements.spectrogramCard.style.display = 'block';

                // æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚’æç”»
                const firstFileName = uploadedFiles[0].name;
                const firstData = spectrogramDataMap.get(firstFileName);
                if (firstData) {
                    renderSpectrogram(firstData);
                }
            }
        }

        // ===========================
        // æ–°æ©Ÿèƒ½3: æ™‚é–“é ˜åŸŸçµ±è¨ˆé‡ã‚°ãƒ©ãƒ•ã®æç”»
        // ===========================
        let timeStatsChart = null;

        function renderTimeStatsChart() {
            const canvas = document.getElementById('timeStatsCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            if (timeStatsChart) {
                timeStatsChart.destroy();
            }

            const datasets = [];

            // æŒ‡æ¨™ã”ã¨ã®è‰²å®šç¾©ï¼ˆè¦‹åˆ†ã‘ã‚„ã™ã„è‰²ï¼‰
            const statColors = {
                crestFactor: 'rgb(37, 99, 235)',    // é’
                kurtosis: 'rgb(220, 38, 38)',       // èµ¤
                peak: 'rgb(34, 197, 94)'            // ç·‘
            };

            // å„ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
            let fileIndex = 0;
            timeStatsDataMap.forEach((statsData, fileName) => {
                if (excludedFiles.includes(fileName)) {
                    fileIndex++;
                    return;
                }

                const offset = fileOffsets.get(fileName) || 0;

                // ã‚¯ãƒ¬ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ï¼ˆé’ç³»ï¼‰
                if (document.getElementById('showCrestFactor')?.checked) {
                    const data = applyDataOffset(statsData.crestFactor, offset);
                    datasets.push({
                        label: `${fileName} - ã‚¯ãƒ¬ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼`,
                        data: data,
                        borderColor: statColors.crestFactor,
                        backgroundColor: rgbStringToRgba(statColors.crestFactor, 0.1),
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1,
                        yAxisID: 'y1'
                    });
                }

                // å°–åº¦ï¼ˆèµ¤ç³»ï¼‰
                if (document.getElementById('showKurtosis')?.checked) {
                    const data = applyDataOffset(statsData.kurtosis, offset);
                    datasets.push({
                        label: `${fileName} - å°–åº¦`,
                        data: data,
                        borderColor: statColors.kurtosis,
                        backgroundColor: rgbStringToRgba(statColors.kurtosis, 0.1),
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1,
                        yAxisID: 'y2'
                    });
                }

                // ãƒ”ãƒ¼ã‚¯å€¤ï¼ˆç·‘ç³»ï¼‰
                if (document.getElementById('showPeak')?.checked) {
                    const data = applyDataOffset(statsData.peak, offset);
                    datasets.push({
                        label: `${fileName} - ãƒ”ãƒ¼ã‚¯å€¤`,
                        data: data,
                        borderColor: statColors.peak,
                        backgroundColor: rgbStringToRgba(statColors.peak, 0.1),
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1,
                        yAxisID: 'y3'
                    });
                }

                fileIndex++;
            });

            timeStatsChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            enabled: tooltipEnabled,
                            mode: tooltipSingleMode ? 'nearest' : 'index',
                            intersect: false,
                            axis: tooltipSingleMode ? 'xy' : 'x',
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    if (tooltipSingleMode && context.length > 0) {
                                        return `æ™‚åˆ»: ${context[0].parsed.x.toFixed(3)}ç§’`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    if (tooltipSingleMode) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                    }
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                drag: { enabled: true },
                                mode: 'xy'
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy'
                            },
                            limits: {
                                x: { min: 'original', max: 'original' },
                                y1: { min: 'original', max: 'original' },
                                y2: { min: 'original', max: 'original' },
                                y3: { min: 'original', max: 'original' }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: true,
                            title: {
                                display: true,
                                text: 'æ™‚é–“ (ç§’)'
                            }
                        },
                        y1: {
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'ã‚¯ãƒ¬ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼'
                            },
                            grid: { display: true }
                        },
                        y2: {
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'å°–åº¦'
                            },
                            grid: { display: false }
                        },
                        y3: {
                            display: false,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'ãƒ”ãƒ¼ã‚¯å€¤'
                            }
                        }
                    }
                }
            });

            document.getElementById('timeStatsCard').style.display = 'block';
        }

        // ===========================
        // æ–°æ©Ÿèƒ½4: ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—åˆ†æã‚°ãƒ©ãƒ•ã®æç”»
        // ===========================
        let envelopeChart = null;

        function renderEnvelopeChart() {
            const canvas = document.getElementById('envelopeCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            if (envelopeChart) {
                envelopeChart.destroy();
            }

            const datasets = [];

            // å„ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
            let fileIndex = 0;
            envelopeDataMap.forEach((envData, fileName) => {
                if (excludedFiles.includes(fileName)) {
                    fileIndex++;
                    return;
                }

                const color = fileColors[fileIndex % fileColors.length];
                const offset = fileOffsets.get(fileName) || 0;

                const data = applyDataOffset(envData.envelope, offset);

                datasets.push({
                    label: `${fileName} - ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—`,
                    data: data,
                    borderColor: color,
                    backgroundColor: rgbStringToRgba(color, 0.1),
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    fill: false
                });

                fileIndex++;
            });

            envelopeChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            enabled: tooltipEnabled,
                            mode: tooltipSingleMode ? 'nearest' : 'index',
                            intersect: false,
                            axis: tooltipSingleMode ? 'xy' : 'x',
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    if (tooltipSingleMode && context.length > 0) {
                                        return `æ™‚åˆ»: ${context[0].parsed.x.toFixed(3)}ç§’`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    if (tooltipSingleMode) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(6)}`;
                                    }
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(6)}`;
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                drag: { enabled: true },
                                mode: 'xy'
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy'
                            },
                            limits: {
                                x: { min: 'original', max: 'original' },
                                y: { min: 'original', max: 'original' }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: true,
                            title: {
                                display: true,
                                text: 'æ™‚é–“ (ç§’)'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—æŒ¯å¹…'
                            }
                        }
                    }
                }
            });

            document.getElementById('envelopeCard').style.display = 'block';
        }

        // ===========================
        // æ–°æ©Ÿèƒ½5: ç•°å¸¸æ¤œçŸ¥ã¨ã‚¢ãƒ©ãƒ¼ãƒˆ
        // ===========================
        function detectAnomalies() {
            const anomalies = [];

            timeStatsDataMap.forEach((statsData, fileName) => {
                if (excludedFiles.includes(fileName)) return;

                // ã‚¯ãƒ¬ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ã®ç•°å¸¸ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
                let crestFactorMax = 0;
                for (let i = 0; i < statsData.crestFactor.length; i++) {
                    if (statsData.crestFactor[i].y > crestFactorMax) {
                        crestFactorMax = statsData.crestFactor[i].y;
                    }
                }
                if (crestFactorMax > anomalyThresholds.crestFactor) {
                    anomalies.push({
                        file: fileName,
                        type: 'ã‚¯ãƒ¬ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ç•°å¸¸',
                        value: crestFactorMax.toFixed(2),
                        threshold: anomalyThresholds.crestFactor,
                        message: 'ãƒ“ãƒ“ã‚ŠæŒ¯å‹•ã¾ãŸã¯å·¥å…·æŠ˜æã®å¯èƒ½æ€§'
                    });
                }

                // å°–åº¦ã®ç•°å¸¸ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
                let kurtosisMax = 0;
                for (let i = 0; i < statsData.kurtosis.length; i++) {
                    if (statsData.kurtosis[i].y > kurtosisMax) {
                        kurtosisMax = statsData.kurtosis[i].y;
                    }
                }
                if (kurtosisMax > 10) {
                    anomalies.push({
                        file: fileName,
                        type: 'å°–åº¦ç•°å¸¸ï¼ˆé‡åº¦ï¼‰',
                        value: kurtosisMax.toFixed(2),
                        threshold: 10,
                        message: 'ãƒ™ã‚¢ãƒªãƒ³ã‚°ç•°å¸¸ï¼ˆé€²è¡Œæ®µéšï¼‰ã®å¯èƒ½æ€§'
                    });
                } else if (kurtosisMax > anomalyThresholds.kurtosis) {
                    anomalies.push({
                        file: fileName,
                        type: 'å°–åº¦ç•°å¸¸ï¼ˆè»½åº¦ï¼‰',
                        value: kurtosisMax.toFixed(2),
                        threshold: anomalyThresholds.kurtosis,
                        message: 'ãƒ™ã‚¢ãƒªãƒ³ã‚°ç•°å¸¸ï¼ˆåˆæœŸæ®µéšï¼‰ã®å¯èƒ½æ€§'
                    });
                }

                // ãƒ”ãƒ¼ã‚¯å€¤ã®ç•°å¸¸ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
                let peakMax = 0;
                for (let i = 0; i < statsData.peak.length; i++) {
                    if (statsData.peak[i].y > peakMax) {
                        peakMax = statsData.peak[i].y;
                    }
                }
                if (peakMax > anomalyThresholds.peak) {
                    anomalies.push({
                        file: fileName,
                        type: 'ãƒ”ãƒ¼ã‚¯å€¤ç•°å¸¸',
                        value: peakMax.toFixed(4),
                        threshold: anomalyThresholds.peak,
                        message: 'çªç™ºçš„ãªè¡æ’ƒã¾ãŸã¯å·¥å…·ç ´æã®å¯èƒ½æ€§'
                    });
                }
            });

            // ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º
            const alertContainer = document.getElementById('anomalyAlertContainer');
            const alertContent = document.getElementById('anomalyAlertContent');

            if (anomalies.length > 0) {
                let html = '<ul style="margin: 0; padding-left: 20px;">';
                anomalies.forEach(anomaly => {
                    html += `<li><strong>${anomaly.file}</strong>: ${anomaly.type} (å€¤: ${anomaly.value}, é–¾å€¤: ${anomaly.threshold})<br>â†’ ${anomaly.message}</li>`;
                });
                html += '</ul>';
                alertContent.innerHTML = html;
                alertContainer.style.display = 'block';
            } else {
                alertContainer.style.display = 'none';
            }
        }

        // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('showCrestFactor')?.addEventListener('change', renderTimeStatsChart);
        document.getElementById('showKurtosis')?.addEventListener('change', renderTimeStatsChart);
        document.getElementById('showPeak')?.addEventListener('change', renderTimeStatsChart);
    </script>
</body>
</html>
