{% extends 'base.html' %}
{% load static %}
{% block title %}ホーム - Daihatsu{% endblock %}
{% block content %}
<style>
  /* ホームページ専用のmain-contentスタイルをリセット */
  #main-content {
    padding: 0 !important;
    margin-left: var(--sidebar-width) !important;
    background: #ffffff !important;
    min-height: 100vh !important;
    height: 100vh !important;
    overflow: hidden !important;
  }

  /* 横スクロールを防ぐ */
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
  }

  .home-hero {
    position: relative;
    width: 100%;
    height: 100vh;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  /* Three.jsキャンバス */
  #three-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }


  /* ヒーローセクション */
  .hero-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10;
    text-align: center;
    animation: fadeIn 2.5s cubic-bezier(0.16, 1, 0.3, 1);
    width: 90%;
    max-width: 1400px;
  }

  @keyframes fadeIn {
    0% {
      opacity: 0;
      transform: translate(-50%, -50%) translateY(50px) scale(0.95);
    }
    100% {
      opacity: 1;
      transform: translate(-50%, -50%) translateY(0) scale(1);
    }
  }

  /* メインテキスト */
  .hero-text {
    position: relative;
    display: inline-block;
    padding: 2rem 3rem;
  }

  .hero-text h1 {
    font-size: 5.5rem;
    font-weight: 800;
    margin: 0;
    background: linear-gradient(135deg,
      #0f0f0f 0%,
      #2c3e50 25%,
      #34495e 50%,
      #2c3e50 75%,
      #0f0f0f 100%);
    background-size: 200% 200%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: 0.4em;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Yu Gothic', 'YuGothic', 'Hiragino Kaku Gothic ProN', sans-serif;
    animation: gradientShift 6s ease-in-out infinite;
  }

  @keyframes gradientShift {
    0%, 100% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
  }

  /* テキスト背景の光とボーダー */
  .hero-text::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 110%;
    height: 140%;
    background: radial-gradient(ellipse at center,
      rgba(255, 255, 255, 0.5) 0%,
      rgba(255, 255, 255, 0.25) 30%,
      transparent 70%);
    z-index: -1;
    animation: glowPulse 4s ease-in-out infinite;
    border-radius: 20px;
  }

  @keyframes glowPulse {
    0%, 100% {
      opacity: 0.7;
      transform: translate(-50%, -50%) scale(1);
    }
    50% {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.08);
    }
  }

  /* 上部装飾ライン */
  .decorative-top {
    margin-bottom: 3rem;
    height: 3px;
    background: linear-gradient(90deg,
      transparent 0%,
      rgba(44, 62, 80, 0.3) 10%,
      #2c3e50 30%,
      #34495e 50%,
      #2c3e50 70%,
      rgba(44, 62, 80, 0.3) 90%,
      transparent 100%);
    position: relative;
    overflow: hidden;
    animation: lineExpand 2s ease-out;
  }

  /* 下部装飾ライン */
  .decorative-bottom {
    margin-top: 3rem;
    height: 3px;
    background: linear-gradient(90deg,
      transparent 0%,
      rgba(44, 62, 80, 0.3) 10%,
      #2c3e50 30%,
      #34495e 50%,
      #2c3e50 70%,
      rgba(44, 62, 80, 0.3) 90%,
      transparent 100%);
    position: relative;
    overflow: hidden;
    animation: lineExpand 2s ease-out 0.3s backwards;
  }

  @keyframes lineExpand {
    0% {
      transform: scaleX(0);
      opacity: 0;
    }
    100% {
      transform: scaleX(1);
      opacity: 1;
    }
  }

  /* ラインのキラキラ効果 */
  .decorative-top::after,
  .decorative-bottom::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 80%;
    height: 100%;
    background: linear-gradient(90deg,
      transparent,
      rgba(255, 255, 255, 0.9),
      transparent);
    animation: shimmer 4s infinite;
  }

  .decorative-bottom::after {
    animation-delay: 2s;
  }

  @keyframes shimmer {
    0% {
      left: -100%;
    }
    100% {
      left: 200%;
    }
  }

  /* サブテキスト */
  .hero-subtitle {
    margin-top: 2rem;
    font-size: 1.1rem;
    color: #2c3e50;
    letter-spacing: 0.5em;
    opacity: 0;
    animation: subtitleFade 1.5s ease-out 1s forwards;
    font-weight: 500;
    text-shadow: 0 2px 10px rgba(255, 255, 255, 0.8);
  }

  @keyframes subtitleFade {
    to {
      opacity: 0.85;
    }
  }

  /* ローディング表示 */
  .loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 5;
    color: #666;
    font-size: 1.2rem;
  }

  @media (max-width: 1200px) {
    .hero-text h1 {
      font-size: 4.5rem;
      letter-spacing: 0.35em;
    }
    .hero-text {
      padding: 1.5rem 2.5rem;
    }
  }

  @media (max-width: 992px) {
    .hero-text h1 {
      font-size: 3.5rem;
      letter-spacing: 0.3em;
    }
    .hero-text {
      padding: 1.2rem 2rem;
    }
    .decorative-top,
    .decorative-bottom {
      margin-top: 2rem;
      margin-bottom: 2rem;
    }
  }

  @media (max-width: 768px) {
    .hero-text h1 {
      font-size: 2.8rem;
      letter-spacing: 0.25em;
    }
    .hero-text {
      padding: 1rem 1.5rem;
    }
    .hero-subtitle {
      font-size: 0.9rem;
      letter-spacing: 0.3em;
    }
  }

  @media (max-width: 480px) {
    .hero-text h1 {
      font-size: 2rem;
      letter-spacing: 0.2em;
    }
    .hero-text {
      padding: 0.8rem 1rem;
    }
    .decorative-top,
    .decorative-bottom {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      height: 2px;
    }
    .hero-subtitle {
      font-size: 0.75rem;
      margin-top: 1rem;
    }
  }

</style>

<div class="home-hero">
  <!-- Three.jsキャンバス -->
  <canvas id="three-canvas"></canvas>

  <!-- ローディング表示 -->
  <div class="loading" id="loading">読み込み中...</div>

  <!-- ヒーローコンテンツ -->
  <div class="hero-content">
    <div class="decorative-top"></div>
    <div class="hero-text">
      <h1>みんなに選ばれる工場へ</h1>
    </div>
    <div class="decorative-bottom"></div>
    <div class="hero-subtitle">DAIHATSU MANUFACTURING SYSTEM</div>
  </div>
</div>

<script type="module">
  import * as THREE from '{% static "js/vendor/three/three.module.js" %}';

  const canvas = document.getElementById('three-canvas');
  const loading = document.getElementById('loading');

  // シーン、カメラ、レンダラーのセットアップ
  const scene = new THREE.Scene();

  // 空のような背景グラデーション
  const vertexShader = `
    varying vec3 vWorldPosition;
    void main() {
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPosition.xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const fragmentShader = `
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float offset;
    uniform float exponent;
    varying vec3 vWorldPosition;

    void main() {
      float h = normalize(vWorldPosition + offset).y;
      gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
    }
  `;

  const uniforms = {
    topColor: { value: new THREE.Color(0x87CEEB) }, // 空色（上部）
    bottomColor: { value: new THREE.Color(0xE8F4FA) }, // 薄い青（下部）
    offset: { value: 33 },
    exponent: { value: 0.6 }
  };

  const skyGeo = new THREE.SphereGeometry(500, 32, 15);
  const skyMat = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    side: THREE.BackSide
  });

  const sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    alpha: false
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);

  camera.position.z = 15;

  // 画像パス（toppageディレクトリから）
  const allImagePaths = [
    '{% static "image/toppage/move.jpeg" %}',
    '{% static "image/toppage/work.jpeg" %}',
    '{% static "image/toppage/work2.jpeg" %}',
    '{% static "image/toppage/work3.jpeg" %}',
    '{% static "image/toppage/work4.jpeg" %}',
    '{% static "image/toppage/work5.jpeg" %}',
    '{% static "image/toppage/work6.jpeg" %}',
    '{% static "image/toppage/work7.jpeg" %}',
    '{% static "image/toppage/work8.jpeg" %}'
  ];

  // ランダムに25枚選択（重複あり）
  const imagePaths = [];
  const imageCount = 25;
  for (let i = 0; i < imageCount; i++) {
    const randomIndex = Math.floor(Math.random() * allImagePaths.length);
    imagePaths.push(allImagePaths[randomIndex]);
  }

  // 画像メッシュの配列
  const meshes = [];

  // テクスチャローダー
  const textureLoader = new THREE.TextureLoader();
  let loadedCount = 0;

  // 画像を立体的に散らす
  imagePaths.forEach((path, index) => {
    textureLoader.load(path, (texture) => {
      const geometry = new THREE.PlaneGeometry(3.5, 3);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.9
      });
      const mesh = new THREE.Mesh(geometry, material);

      // 円形に配置しつつ、Z軸にも散らす（立体的）
      const angle = (index / imagePaths.length) * Math.PI * 2;
      const radius = 12;
      const x = Math.cos(angle) * radius;
      const y = (Math.random() - 0.5) * 8; // Y軸にランダム配置
      const z = Math.sin(angle) * radius;

      mesh.position.set(x, y, z);

      // 正面を向く（回転なし）
      mesh.rotation.set(0, 0, 0);

      // ランダムな動きのタイプを決定（0: 円形軌道, 1: 直線移動（横）, 2: 直線移動（縦）, 3: 直線移動（斜め））
      const movementType = Math.floor(Math.random() * 4);

      // アニメーション用のカスタムプロパティ
      mesh.userData = {
        originalX: x,
        originalY: y,
        originalZ: z,
        floatSpeed: Math.random() * 0.0008 + 0.0005,
        floatOffset: Math.random() * Math.PI * 2,
        angle: angle,
        radius: radius,
        movementType: movementType,
        // 直線移動用（一定方向への移動）
        driftSpeedX: (Math.random() - 0.5) * 0.008,
        driftSpeedY: (Math.random() - 0.5) * 0.006,
        driftSpeedZ: (Math.random() - 0.5) * 0.003,
        // 揺らぎ用（微妙な浮遊）
        waveSpeedX: Math.random() * 0.15 + 0.1,
        waveSpeedY: Math.random() * 0.12 + 0.08,
        waveRangeX: Math.random() * 1.5 + 0.8,
        waveRangeY: Math.random() * 1.2 + 0.6
      };

      scene.add(mesh);
      meshes.push(mesh);

      loadedCount++;
      if (loadedCount === imagePaths.length) {
        loading.style.display = 'none';
      }
    });
  });

  // アンビエントライト
  const ambientLight = new THREE.AmbientLight(0xffffff, 1.3);
  scene.add(ambientLight);

  // 太陽光（ディレクショナルライト）
  const sunLight = new THREE.DirectionalLight(0xffffee, 0.6);
  sunLight.position.set(50, 50, 50);
  scene.add(sunLight);

  // アニメーションループ
  let time = 0;
  function animate() {
    requestAnimationFrame(animate);
    time += 0.01;

    // 画像のアニメーション
    meshes.forEach((mesh, index) => {
      const userData = mesh.userData;

      switch(userData.movementType) {
        case 0: // ゆっくり円形軌道
          const orbitSpeed = 0.02;
          const newAngle = userData.angle + time * orbitSpeed;
          const radiusWave = Math.sin(time * 0.1 + userData.floatOffset) * 0.2;
          const currentRadius = userData.radius + radiusWave;

          mesh.position.x = Math.cos(newAngle) * currentRadius;
          mesh.position.z = Math.sin(newAngle) * currentRadius;

          // 微妙な上下浮遊
          const floatY = Math.sin(time * 0.2 + userData.floatOffset) * 0.4;
          mesh.position.y = userData.originalY + floatY;
          break;

        case 1: // 一定方向への横移動 + 微妙な揺らぎ
          // 一定方向への移動（ドリフト）
          userData.originalX += userData.driftSpeedX;
          userData.originalZ += userData.driftSpeedZ * 0.3;

          // 微妙な波のような揺らぎ
          const waveX = Math.sin(time * userData.waveSpeedX + userData.floatOffset) * userData.waveRangeX;
          const waveY = Math.sin(time * userData.waveSpeedY + userData.floatOffset) * userData.waveRangeY;

          mesh.position.x = userData.originalX + waveX;
          mesh.position.y = userData.originalY + waveY;
          mesh.position.z = userData.originalZ;
          break;

        case 2: // 一定方向への縦移動 + 微妙な揺らぎ
          // 一定方向への移動（ドリフト）
          userData.originalY += userData.driftSpeedY;
          userData.originalZ += userData.driftSpeedZ * 0.3;

          // 微妙な波のような揺らぎ
          const waveX2 = Math.sin(time * userData.waveSpeedX + userData.floatOffset) * userData.waveRangeX;
          const waveY2 = Math.sin(time * userData.waveSpeedY + userData.floatOffset) * userData.waveRangeY * 0.5;

          mesh.position.x = userData.originalX + waveX2;
          mesh.position.y = userData.originalY + waveY2;
          mesh.position.z = userData.originalZ;
          break;

        case 3: // 一定方向への斜め移動 + 微妙な揺らぎ
          // 一定方向への移動（ドリフト）
          userData.originalX += userData.driftSpeedX;
          userData.originalY += userData.driftSpeedY;
          userData.originalZ += userData.driftSpeedZ * 0.3;

          // 微妙な波のような揺らぎ
          const waveX3 = Math.sin(time * userData.waveSpeedX + userData.floatOffset) * userData.waveRangeX;
          const waveY3 = Math.sin(time * userData.waveSpeedY + userData.floatOffset) * userData.waveRangeY;

          mesh.position.x = userData.originalX + waveX3;
          mesh.position.y = userData.originalY + waveY3;
          mesh.position.z = userData.originalZ;
          break;
      }

      // 全ての画像は回転させない
    });

    // カメラを緩やかに動かす
    camera.position.x = Math.sin(time * 0.1) * 2;
    camera.position.y = Math.cos(time * 0.08) * 1.5;
    camera.lookAt(0, 0, 0);

    renderer.render(scene, camera);
  }

  // アニメーション開始
  animate();

  // リサイズ対応
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
{% endblock %}
